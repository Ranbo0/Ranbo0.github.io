[{"title":"CUDA beginning","url":"/2021/11/11/CUDA-beginning/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"〇、-什么是-CUDA\"><a href=\"#〇、-什么是-CUDA\" class=\"headerlink\" title=\"〇、 什么是 CUDA\"></a>〇、 什么是 <code>CUDA</code></h1><p><code>CUDA</code>（<code>Compute Unified Device Architecture</code>），是显卡厂商 <a href=\"https://baike.baidu.com/item/NVIDIA\"><code>NVIDIA</code></a> 推出的运算平台。 CUDA™是一种由NVIDIA推出的通用 <a href=\"https://baike.baidu.com/item/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/113443\">并行计算</a> 架构，该架构使 <a href=\"https://baike.baidu.com/item/GPU\"><code>GPU</code></a> 架构，该架构使 <a href=\"https://baike.baidu.com/item/GPU\"><code>GPU</code></a> 能够解决复杂的计算问题。 它包含了CUDA<a href=\"https://baike.baidu.com/item/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%9E%84\">指令集架构</a>（<a href=\"https://baike.baidu.com/item/ISA\"><code>ISA</code></a>）以及GPU内部的并行计算引擎。 开发人员可以使用<a href=\"https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80\"><code>C</code>语言</a>来为<code>CUDA™</code>架构编写程序，所编写出的程序可以在支持<code>CUDA™</code>的处理器上以超高性能运行。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h1 id=\"一、-引言\"><a href=\"#一、-引言\" class=\"headerlink\" title=\"一、 引言\"></a>一、 引言</h1><h2 id=\"1-1-GPU-的诞生\"><a href=\"#1-1-GPU-的诞生\" class=\"headerlink\" title=\"1.1 GPU 的诞生\"></a>1.1 <code>GPU</code> 的诞生</h2><p>​    <code>CPU</code>的计算速度无法满足需求，大部分坐标处理工作及光影特效需要 <code>CPU</code> 亲自完成，占用太多运算时间，造成整体画面不能流畅的表现出来。随着时间的推移，<code>CPU</code> 进行各种光影计算的速度变得越来越无法满足游戏开发商的需求，更多特效的应用也几乎榨干了 <code>CPU</code> 的性能，因此，矛盾产生了，<code>GPU</code> 应运而生。</p>\n<h2 id=\"1-2-GPU-概述\"><a href=\"#1-2-GPU-概述\" class=\"headerlink\" title=\"1.2 GPU 概述\"></a>1.2 <code>GPU</code> 概述</h2><p><code>GPU</code>（<code>Graphics Processing Unit</code>）是一种特殊类型的处理器，具有数百或数千个内核，可并行运行大量计算。<code>GPU</code>是一种专门在<code>PC</code>，游戏机，手机等设备上上运行绘图运算工作的<a href=\"https://baike.hk.xileso.top/baike-%E5%BE%AE%E8%99%95%E7%90%86%E5%99%A8\">微处理器</a>。虽然<code>GPU</code>在游戏中以<a href=\"https://baike.hk.xileso.top/baike-3D%E6%B8%B2%E6%9F%93\">3D</a><a href=\"https://baike.hk.xileso.top/baike-3D%E6%B8%B2%E6%9F%93\">渲染</a>而闻名，但它们对运行分析、<a href=\"https://baike.hk.xileso.top/baike-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0\">深度学习</a>和<a href=\"https://baike.hk.xileso.top/baike-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\">机器学习</a>算法尤其有用。GPU允许某些计算比传统CPU上运行相同的计算速度快<code>10</code>倍至<code>100</code>倍。</p>\n<h2 id=\"1-3-CUDA-产生\"><a href=\"#1-3-CUDA-产生\" class=\"headerlink\" title=\"1.3 CUDA 产生\"></a>1.3 <code>CUDA</code> 产生</h2><p><code>GPU</code>的高效在于可以高度并行处理。 以两个向量相加为例，<code>CPU</code>可能采取循环处理，每个循环对一个分量做加法。<code>GPU</code>则可以开多个线程，每个线程同时对一个分量做加法。<code>CPU</code>加法的速度一般快于<code>GPU</code>，但因为<code>GPU</code>可以同时开大量线程并行跑，因此更加高效。</p>\n<p>为了降低<code>GPU</code>程序的开发难度，<code>NVIDIA</code>推出了 <code>CUDA</code>（<code>Compute Unified Device Architecture</code>，统一计算设备架构）这一编程模型。</p>\n<h2 id=\"1-4-CPU-和-GPU-模型对比\"><a href=\"#1-4-CPU-和-GPU-模型对比\" class=\"headerlink\" title=\"1.4 CPU 和 GPU 模型对比\"></a>1.4 <code>CPU</code> 和 <code>GPU</code> 模型对比</h2><h3 id=\"1-4-1-CPU-架构\"><a href=\"#1-4-1-CPU-架构\" class=\"headerlink\" title=\"1.4.1 CPU 架构\"></a>1.4.1 <code>CPU</code> 架构</h3><p>![](CPU Arch.png)</p>\n<p><code>CPU</code>（<code>Central Processing Unit</code>, 中央处理器）：<code>CPU</code>的结构主要包括运算器（<code>ALU</code>, <code>Arithmetic and Logic Unit</code>）、控制单元（<code>CU</code>, <code>Control Unit</code>）、寄存器（<code>Register</code>）、高速缓存器（<code>Cache</code>）等。简单来说就是<strong>计算单元，控制单元，存储单元</strong>。<strong>计算能力</strong>是CPU的很小的一部分功能。</p>\n<ul>\n<li><p><code>ALU</code> — 运算单元</p>\n</li>\n<li><p><code>Control</code> — 控制单元</p>\n</li>\n<li><p><code>Cache</code> — 高速缓存（<code>CPU</code>和内存之间的中介桥梁），进行高速数据交换的存储器</p>\n</li>\n<li><p><code>DRAM </code>— 进行短暂存储的存储器，易失性存储器（电源开启时数据存在，断开电源数据消失）</p>\n</li>\n</ul>\n<p>可以看出 <code>CPU</code><strong>是基于低延迟设计</strong> 的。因为它有<strong>特别大的缓存空间可以降低延时</strong>，可以保存较多数据在缓存里面，当需要访问的这些数据时，只要在之前访问过的，现在直接在缓存里面取即可。</p>\n<p>此外，<code>CPU</code>具有复杂的控制单元。例如当程序含有多个分支的时候，它可以通过提供分支预测的能力来降低延时。再比如在数据转发时，当一些指令依赖前面的指令结果时，数据转发的逻辑控制单元决定这些指令在<code>pipeline</code>中的位置并且尽可能快的转发一个指令的结果给后续的指令。这些动作需要很多的对比电路单元和转发电路单元。</p>\n<p>因为<code>CPU</code>的架构中需要大量的空间去放置存储单元和控制单元，相比之下计算单元只占据了很小的一部分，所以它在大规模并行计算能力上极受限制，而更擅长于逻辑控制。</p>\n<h3 id=\"1-4-2-GPU-架构\"><a href=\"#1-4-2-GPU-架构\" class=\"headerlink\" title=\"1.4.2 GPU 架构\"></a>1.4.2 <code>GPU</code> 架构</h3><p>![](GPU Arch.png)</p>\n<p><code>GPU</code>的结构里有大量的<code>ALU</code>（计算单元）单元和很少的<code>Cache</code>（缓存）。</p>\n<p><code>GPU</code>的<code>Cache</code>不是像<code>CPU</code>那样保存后面需要访问的数据的，它是为<code>thread</code>（线程）提供服务的。如果有很多线程需要访问同一个相同的数据，缓存会合并这些访问，然后再去访问<code>dram</code>（因为需要访问的数据保存在<code>dram</code>中而不是<code>cache</code>里面），获取数据后<code>cache</code>会转发这个数据给对应的线程，这个时候<code>Cache</code>是作为数据转发的角色。但是由于需要访问<code>dram</code>，自然会带来延时的问题。</p>\n<p><code>GPU</code>的工作大部分都计算量大，但没什么技术含量，而且要<strong>重复很多很多次</strong>。也就是说，<code>GPU</code>是用很多简单的计算单元去完成大量的计算任务，纯粹的人海战术。所以<code>GPU</code>的计算特点就是<strong>超长的流水线</strong>和<strong>并行计算</strong>。显然，<code>GPU</code>是基于高吞吐量设计的。</p>\n<h2 id=\"1-5-串行计算和并行计算\"><a href=\"#1-5-串行计算和并行计算\" class=\"headerlink\" title=\"1.5 串行计算和并行计算\"></a>1.5 串行计算和并行计算</h2><p>串行计算可以看成是将某个任务分解成一系列小任务，把这些小任务一一完成。在串行计算时，我们的想法就是让处理器每次处理一个计算任务，处理完一个计算任务后再计算下一个任务，直到所有小任务都完成了，那么这个大的程序任务也就完成了。<code>CPU</code> 的每个核心自身能力极强，处理任务上非常强悍，但是他核心少，所以 <code>CPU</code> 特别擅长串行计算。</p>\n<p><img src=\"/2021/11/11/CUDA-beginning/sol.png\"></p>\n<p>当我们可以利用多核处理器同时处理多个任务时，为了进一步加快大任务的计算速度，我们可以把一些小任务分配到不同的处理器上进行同时计算，最后再将这些结果进行整合，完成一次任务计算。<code>GPU</code>的每个核心的计算能力不如<code>CPU</code>，但是它核心非常多，可同时处理多个计算任务，所以<code>GPU</code>擅长并行计算。</p>\n<p><img src=\"/2021/11/11/CUDA-beginning/par.png\"></p>\n<p>所以，要加快程序的运行速度，可以先分析程序中哪些部分是强耦合的，哪些部分是相对独立的，对于强耦合的部分可以使用串行计算，而对于相对独立的部分，则可以充分利用多核处理器的优势进一步加速我们的计算任务，使用并行计算加快计算速度。因此，利用串行+并行的编程思路即可完成一次高性能计算，也就是充分利用<code>CPU</code>和<code>GPU</code>的优势来使程序性能得到优化。</p>\n<h1 id=\"二、-CUDA-模型\"><a href=\"#二、-CUDA-模型\" class=\"headerlink\" title=\"二、 CUDA 模型\"></a>二、 <code>CUDA</code> 模型</h1><h2 id=\"2-1-CUDA-程序执行过程\"><a href=\"#2-1-CUDA-程序执行过程\" class=\"headerlink\" title=\"2.1 CUDA 程序执行过程\"></a>2.1 <code>CUDA</code> 程序执行过程</h2><p>典型的<code>CUDA</code>程序实现流程如下：</p>\n<ol>\n<li>把数据从<code>CPU</code>内存拷贝到<code>GPU</code>内存；</li>\n<li>调用核函数对存储在<code>GPU</code>内存中的数据进行操作；</li>\n<li>将数据从<code>GPU</code>内存传送到<code>CPU</code>内存。</li>\n</ol>\n<p><img src=\"/2021/11/11/CUDA-beginning/cuda1.png\"></p>\n<h2 id=\"2-2-CUDA-线程模型\"><a href=\"#2-2-CUDA-线程模型\" class=\"headerlink\" title=\"2.2 CUDA 线程模型\"></a>2.2 <code>CUDA</code> 线程模型</h2><p><code>kernel</code>在<code>device</code>上执行时实际上是启动很多线程，一个<code>kernel</code>所启动的所有线程称为一个网格（<code>grid</code>），同一个网格上的线程共享相同的全局内存空间，<code>grid</code>是线程结构的第一层次，而网格又可以分为很多线程块（<code>block</code>），一个线程块里面包含很多线程，这是第二个层次。</p>\n<p><img src=\"/2021/11/11/CUDA-beginning/thread.png\"></p>\n<p>理想的主机端的串行代码只负责上一个<code>kernel</code>函数的清理和为下一个<code>kernel</code>函数进行准备，这样可以充分发挥<code>GPU</code>的高效运算能力，减少内存和显存之间传递数据的开销。但是在实践中一般无法将所有的计算任务交给设备端处理，主机端的串行代码中还应包含一些并行度较小的计算任务。</p>\n<h2 id=\"2-3-CUDA-内存模型\"><a href=\"#2-3-CUDA-内存模型\" class=\"headerlink\" title=\"2.3 CUDA 内存模型\"></a>2.3 <code>CUDA</code> 内存模型</h2><p><code>CUDA</code>编程模型本质是从<code>GPU</code>架构中抽象出的一个内存层次结构，通过在<code>CUDA</code>上进行开发可以对<code>GPU</code>不同的内存层次进行处理。由于<code>LRC</code>码在编解码的过程中会进行数据的分组分割，需要对原始数据块进行存储处理等操作，为了加快<code>LRC</code>码的编解码性能，可以将分割分组后的数据存储到<code>GPU</code>的不同内存层次中去，这一点可以利用<code>CUDA</code>编程实现。因此，对于<code>CUDA</code>模型中不同的内存层次结构的了解很有必要。</p>\n<p>在设备端全局内存类似于<code>CPU</code>的系统内存，具有存储空间大但是内存带宽低、时延较高的特点，而共享内存则类似于<code>CPU</code>的缓存，具有的存储空间比线程自带的寄存器空间要大且拥有高内存带宽以及低时延。其中，<code>GPU</code>的共享内存可以由<code>CUDA_C</code>的内核直接控制。</p>\n<p><img src=\"/2021/11/11/CUDA-beginning/memory.png\"></p>\n<p>上图即为 <code>CUDA</code> 内存模型，前文已经介绍过 <code>Grid - Block - Thread</code> 的线程结构，在内存模型中，一个 <code>Grid</code> 中的所有 <code>Block</code> 的线程可以共享访问 <strong>全局内存</strong> 、 <strong>常量内存</strong> 、 <strong>纹理内存</strong> 的数据，在一个 <code>Block</code> 中，所有线程 <code>Thread</code> 可以共享访问 <strong>本地内存</strong> （<strong>共享内存</strong>）的数据。</p>\n<h1 id=\"三、-CUDA-核函数\"><a href=\"#三、-CUDA-核函数\" class=\"headerlink\" title=\"三、 CUDA 核函数\"></a>三、 <code>CUDA</code> 核函数</h1><p>假如我们要计算 <code>10000</code> 个 <code>0</code> 到 <code>9</code> 的随机数立方和，用 <code>C</code> 写应该是这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DATA_SIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// generate random number</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GenerateFunc</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        dat[i] = rand() % <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRes</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        ret += dat[i] * dat[i] * dat[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[DATA_SIZE];</span><br><span class=\"line\">    GenerateFunc(data, DATA_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = getRes(data, DATA_SIZE);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ret = %d\\n&quot;</span>, ret);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么我们如何让这个工作在显卡上完成呢？首先第一件事很显而易见，这些数字不能放在内存里了，而是要复制到<code>GPU</code>的显存上。</p>\n<p>前文已经介绍过，在 <code>CUDA </code>的架构下，一个程序分为两个部份：<code>host </code>端和 <code>device </code>端。<code>Host </code>端是指在 <code>CPU </code>上执行的部份，而 <code>device </code>端则是在显示芯片上执行的部份。<code>Device </code>端的程序又称为 <code>kernel</code>。通常 <code>host </code>端程序会将数据准备好后，复制到显卡的内存中，再由显示芯片执行 <code>device </code>端程序，完成后再由 <code>host </code>端程序将结果从显卡的内存中取回。</p>\n<p>我们需要把产生的数据复制到<code>Device</code>端的<code>RAM</code>，才能在显卡上完成计算，因此我们首先开辟一块合适的显存，然后把随机数从内存复制进去。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*把数据复制到显卡内存中*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* gpudata, *result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cudaMalloc 取得一块显卡内存 ( 其中result用来存储计算结果 )</span></span><br><span class=\"line\">cudaMalloc((<span class=\"keyword\">void</span>**)&amp;gpudata, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE);</span><br><span class=\"line\">cudaMalloc((<span class=\"keyword\">void</span>**)&amp;result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpy 将产生的随机数复制到显卡内存中 </span></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpyHostToDevice - 从内存复制到显卡内存</span></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpyDeviceToHost - 从显卡内存复制到内存</span></span><br><span class=\"line\">cudaMemcpy(gpudata, data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE,cudaMemcpyHostToDevice);</span><br></pre></td></tr></table></figure>\n\n<p><code>cudaMalloc </code>和 <code>cudaMemcpy </code>的用法和一般的 <code>malloc </code>及 <code>memcpy </code>类似，不过 <code>cudaMemcpy </code>则多出一个参数，指示复制内存的方向。在这里因为是从主内存复制到显卡内存，所以使用 <code>cudaMemcpyHostToDevice</code>。如果是从显卡内存到主内存，则使用<code>cudaMemcpyDeviceToHost</code>。</p>\n<p>完成了从内存到显存的数据拷贝之后，我们接下来就要在显卡上完成计算了。</p>\n<p><code>CUDA</code> 核函数就是要写在显示芯片上执行的程序。在 <code>CUDA </code>中，在函数前面加上<code>__global__</code> 表示这个函式是要在显示芯片上执行的,所以我们只要在正常函数之前加上一个<code>__global__</code>就行了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getRes</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span>* res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; DATA_SIZE; i++) &#123;</span><br><span class=\"line\">        sum += dat[i] * dat[i] * dat[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *res = sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在 <code>C</code> 源代码中该接口是以 <code>int</code> 型返回的，但是这里的返回值是 <code>void</code> ，需要注意，所有在 <code>device</code> 端执行的代码，即前缀包含 <code>__global__</code> 的接口必须以 <code>void</code> 返回，也就是无返回值，所有需要返回的数据都要在参数列表中以参数的形式传入和修改。</p>\n<p>写好核函数之后需要让<code>CUDA</code>执行这个函数。在 <code>CUDA </code>中，要执行一个核函数，使用以下的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">functionName&lt;&lt;&lt;blockNum, threadNum, shared_memory_size&gt;&gt;&gt;(args...);</span><br></pre></td></tr></table></figure>\n\n<p>例如，我们令 <code>block</code> 数量为 <code>1</code> ，每个 <code>block</code> 中的 <code>thread</code> 数量为 <code>1</code>，不使用共享内存，则调用核函数的接口的方式为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">getRes&lt;&lt;&lt;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&gt;&gt;&gt;(gpudata, result);</span><br></pre></td></tr></table></figure>\n\n<p>很显然，令 <code>block</code> 数量为 <code>1</code> ，每个 <code>block</code> 中的 <code>thread</code> 数量为 <code>1</code>，不使用共享内存，这样的话就是单纯的让单个线程完成计算，没有涉及到多线程并行计算。计算完了，千万别忘了还要<strong>把结果从显示芯片复制回主内存上</strong>，然后<strong>释放掉内存</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//cudaMemcpy -- copy result from device to host</span></span><br><span class=\"line\">    cudaMemcpy(&amp;sum, result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), cudaMemcpyDeviceToHost);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Free memory</span></span><br><span class=\"line\">    cudaFree(gpudata);</span><br><span class=\"line\">    cudaFree(result);</span><br></pre></td></tr></table></figure>\n\n<p>完整程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//CUDA RunTime API</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cuda_runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DATA_SIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> data[DATA_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GenerateFunc</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        dat[i] = rand() % <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CUDA 初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">InitCUDA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"comment\">//取得支持Cuda的装置的数目</span></span><br><span class=\"line\">    cudaGetDeviceCount(&amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;There is no device.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        cudaDeviceProp prop;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cudaGetDeviceProperties(&amp;prop, i) == cudaSuccess) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prop.major &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == count) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;There is no device supporting CUDA 1.x.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cudaSetDevice(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getRes</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span>* res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; DATA_SIZE; i++) &#123;</span><br><span class=\"line\">        sum += dat[i] * dat[i] * dat[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *res = sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//CUDA 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!InitCUDA()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    GenerateNumbers(data, DATA_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* gpudata, *result;</span><br><span class=\"line\">    cudaMalloc((<span class=\"keyword\">void</span>**)&amp;gpudata, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE);</span><br><span class=\"line\">    cudaMalloc((<span class=\"keyword\">void</span>**)&amp;result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    cudaMemcpy(gpudata, data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE, cudaMemcpyHostToDevice);</span><br><span class=\"line\">    sumOfSquares &lt;&lt;&lt;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&gt;&gt;&gt;(gpudata, result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    cudaMemcpy(&amp;sum, result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), cudaMemcpyDeviceToHost);</span><br><span class=\"line\"></span><br><span class=\"line\">    cudaFree(gpudata);</span><br><span class=\"line\">    cudaFree(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;GPU result: %d\\n&quot;</span>, sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; DATA_SIZE; i++) &#123;</span><br><span class=\"line\">        sum += data[i] * data[i] * data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;CPU result: %d\\n&quot;</span>, sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四、-核函数运行参数\"><a href=\"#四、-核函数运行参数\" class=\"headerlink\" title=\"四、 核函数运行参数\"></a>四、 核函数运行参数</h1><p>上一个部分介绍了核函数的一种调用形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">functionName&lt;&lt;&lt;blockNum, threadNum, shared_memory_size&gt;&gt;&gt;(args...);</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>&lt;&lt;&lt; &gt;&gt;&gt;</code> 标识了核函数的启动方式。实际上，当我们定义了核函数，并将其标识为 <code>__global__</code> 后：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">kernel</span><span class=\"params\">(param1, ...)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在主机端调用时应采用如下的形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">kernel&lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt;(param1, ...);</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>Dg</code> 是 <code>dim3</code> 类型的， <code>dim3</code> 即基于 <code>unsigned int</code> 定义的矢量类型，实质上是 <code>3</code> 个 <code>unsigned int</code> 组成的结构体，用来定义 <code>grid</code> 的维度和尺寸，即 <code>grid</code> 每行有 <code>Dg.x</code> 个 <code>block</code> ，每列有 <code>Dg.y</code> 个 <code>block</code> ，高度为 <code>Dg.z</code> ；</li>\n<li><code>Db</code> 是 <code>dim3</code> 类型的，用来定义 <code>block</code> 的维度和尺寸，即 <code>block</code> 每行有 <code>Db.x</code> 个 <code>thread</code> ，每列有 <code>Db.y</code> 个 <code>thread</code> ，高度为 <code>Db.z</code> ；</li>\n<li><code>Ns</code>： <code>size_t</code> 类型，可缺省，默认为 <code>0</code> 。 用于设置每个 <code>block</code> 除了静态分配的共享内存外，最多能动态分配的共享内存大小，单位为 <code>byte</code> 。 <code>0</code> 表示不需要动态分配；</li>\n<li><code>S</code>： <code>cudaStream_t</code> 类型，可缺省，默认为 <code>0</code> 。 表示该核函数位于哪个流。</li>\n</ul>\n<p>前面已经介绍了 <code>GPU</code> 的线程结构，结合之前的线程结构更容易理解。</p>\n<h2 id=\"4-1-核函数举例之矢量相加\"><a href=\"#4-1-核函数举例之矢量相加\" class=\"headerlink\" title=\"4.1 核函数举例之矢量相加\"></a>4.1 核函数举例之矢量相加</h2><h3 id=\"4-1-1-一维-grid-，一维-block\"><a href=\"#4-1-1-一维-grid-，一维-block\" class=\"headerlink\" title=\"4.1.1 一维 grid ，一维 block\"></a>4.1.1 一维 <code>grid</code> ，一维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-2-一维-grid-，二维-block\"><a href=\"#4-1-2-一维-grid-，二维-block\" class=\"headerlink\" title=\"4.1.2 一维 grid ，二维 block\"></a>4.1.2 一维 <code>grid</code> ，二维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 2-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x * blockDim.y + threadIdx.y * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-3-一维-grid-，三维-block\"><a href=\"#4-1-3-一维-grid-，三维-block\" class=\"headerlink\" title=\"4.1.3 一维 grid ，三维 block\"></a>4.1.3 一维 <code>grid</code> ，三维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 3-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x * blockDim.y * blockDim.z</span><br><span class=\"line\">            + threadIdx.z * blockDim.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-4-二维-grid-，一维-block\"><a href=\"#4-1-4-二维-grid-，一维-block\" class=\"headerlink\" title=\"4.1.4 二维 grid ，一维 block\"></a>4.1.4 二维 <code>grid</code> ，一维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G2_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 2-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-5-二维-grid-，二维-block\"><a href=\"#4-1-5-二维-grid-，二维-block\" class=\"headerlink\" title=\"4.1.5 二维 grid ，二维 block\"></a>4.1.5 二维 <code>grid</code> ，二维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G2_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 2-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 2-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-6-二维-grid-，三维-block\"><a href=\"#4-1-6-二维-grid-，三维-block\" class=\"headerlink\" title=\"4.1.6 二维 grid ，三维 block\"></a>4.1.6 二维 <code>grid</code> ，三维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G2_B3</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 2-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 3-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y * blockDim.z)</span><br><span class=\"line\">            + threadIdx.z * (blockDim.y * blockDim.x)</span><br><span class=\"line\">            + threadIdx.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-7-三维-grid-，一维-block\"><a href=\"#4-1-7-三维-grid-，一维-block\" class=\"headerlink\" title=\"4.1.7 三维 grid ，一维 block\"></a>4.1.7 三维 <code>grid</code> ，一维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G3_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 3-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.z * gridDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-8-三维-grid-，二维-block\"><a href=\"#4-1-8-三维-grid-，二维-block\" class=\"headerlink\" title=\"4.1.8 三维 grid ，二维 block\"></a>4.1.8 三维 <code>grid</code> ，二维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G3_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 3-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 2-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.z * gridDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-1-9-三维-grid-，三维-block\"><a href=\"#4-1-9-三维-grid-，三维-block\" class=\"headerlink\" title=\"4.1.9 三维 grid ，三维 block\"></a>4.1.9 三维 <code>grid</code> ，三维 <code>block</code></h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G3_B3</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 3-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 3-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.z * gridDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y * blockDim.z)</span><br><span class=\"line\">            + threadIdx.z * (blockDim.y * blockDim.x)</span><br><span class=\"line\">            + threadIdx.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-任务调度\"><a href=\"#4-2-任务调度\" class=\"headerlink\" title=\"4.2 任务调度\"></a>4.2 任务调度</h2><p>以上面的 <code>addKernel_G1_B1</code> 为例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addKernel_G1_B1&lt;&lt;&lt;<span class=\"number\">1</span>, size&gt;&gt;&gt;(dev, dev_a, dev_b);</span><br></pre></td></tr></table></figure>\n\n<p>当 <code>size &gt; 1024</code> 时，矢量会过长，因为一个 <code>block</code> 能容纳的线程数至多为 <code>1024</code> 。于是我们可以采用多个线程块来解决线程不足的问题。 假如我们设定每个线程块包含 <code>128</code> 个线程，则需要的线程块的数量为 <code>size / 128</code> 。 为了避免不能整除带来的问题，我们可以稍微多开一点 <code>(size + 127) / 128</code> ，但需要增加判断条件来避免越界。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tid &lt; size)</span><br><span class=\"line\">        c[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行核函数，运行设置为多个block，每个block中128个线程</span></span><br><span class=\"line\">addKernel &lt;&lt;&lt;(size + <span class=\"number\">127</span>) / <span class=\"number\">128</span>, <span class=\"number\">128</span> &gt;&gt;&gt;(dev, dev_a, dev_b, size);</span><br></pre></td></tr></table></figure>\n\n<p>如果数据量大于 <code>Block_num * Thread_num</code>，那么我们就无法为每个分量单独分配一个线程了。 不过，一个简单的解决办法就是在核函数中增加循环。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tid &lt; size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        c[tid] = a[tid] + b[tid];</span><br><span class=\"line\">        <span class=\"comment\">// 偏移分量等于一个Grid中包含的线程数量</span></span><br><span class=\"line\">        tid += blockDim.x * gridDim.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行核函数，运行设置为1个Grid包含128个block，每个block包含128个线程</span></span><br><span class=\"line\"><span class=\"comment\">// 其中已经假设 size &gt; 128*128</span></span><br><span class=\"line\">addKernel &lt;&lt;&lt;<span class=\"number\">128</span>, <span class=\"number\">128</span>&gt;&gt;&gt;(dev, dev_a, dev_b, size);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-线程同步\"><a href=\"#4-3-线程同步\" class=\"headerlink\" title=\"4.3 线程同步\"></a>4.3 线程同步</h2><p>同一个 <code>Block</code> 中的线程可以访问一块共享内存。由于共享内存缓冲区驻留在物理 <code>GPU</code> 上（片上内存），而不是 <code>GPU</code> 之外的系统内存（片外内存）上，因此访问共享内存的延迟要远远低于访问普通缓冲区的延迟。</p>\n<p>不同 <code>Block</code> 之间存在隔离，如果我们需要不同线程之间进行通信，那么还需要考虑线程同步的问题。比如线程<code>1</code> 将某个数值写入内存，然后线程 <code>2</code> 会对该数值进行一些操作，那么显然必须等 <code>1</code> 完成之后 <code>2</code> 才可以操作，如果没有同步，程序将会因进入“竞态条件”而产生意想不到的错误。</p>\n<p>(updating…)</p>\n","categories":["CUDA"],"tags":["CUDA"]},{"title":"my first blog","url":"/2021/11/09/first%20blog/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>我的第一个博客。</p>\n<span id=\"more\"></span>\n\n<p>一些帮助链接：</p>\n<p><a href=\"https://hexo.io/\">Hexo</a></p>\n<p><a href=\"https://hexo.io/docs/\">documentation</a></p>\n<p><a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a></p>\n<p><a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a></p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","tags":["test"]},{"title":"用github搭建博客巨无敌详细教程","url":"/2021/11/09/blog/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"一、-环境准备\"><a href=\"#一、-环境准备\" class=\"headerlink\" title=\"一、 环境准备\"></a>一、 环境准备</h1><h2 id=\"1-git\"><a href=\"#1-git\" class=\"headerlink\" title=\"1. git\"></a>1. <code>git</code></h2><p>$\\text{link:}$ </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://git-scm.com/</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"2-node\"><a href=\"#2-node\" class=\"headerlink\" title=\"2. node\"></a>2. <code>node</code></h2><p>$\\text{link: }$</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://nodejs.org/en/download/</span><br></pre></td></tr></table></figure>\n\n<p>安装完成后输入 <code>node -v</code></p>\n<p><img src=\"/2021/11/09/blog/2.png\"></p>\n<p>输出版本号就安装完成了。</p>\n<h2 id=\"3-hexo\"><a href=\"#3-hexo\" class=\"headerlink\" title=\"3. hexo\"></a>3. <code>hexo</code></h2><p><code>npm install hexo -g</code></p>\n<p>安装完成后输入 <code>hexo -v</code></p>\n<p><img src=\"/2021/11/09/blog/1.png\"></p>\n<p>输出 <code>hexo</code> 以及 <code>hexo</code> 的部分依赖的版本号即安装完成。</p>\n<p>安装 <code>hexo</code> 依赖：</p>\n<p><code>npm install --save hexo-deployer-git</code></p>\n<h1 id=\"二、-配置-ssh-key-（可选）\"><a href=\"#二、-配置-ssh-key-（可选）\" class=\"headerlink\" title=\"二、 配置 ssh-key （可选）\"></a>二、 配置 <code>ssh-key</code> （可选）</h1><h2 id=\"1-配置-ssh\"><a href=\"#1-配置-ssh\" class=\"headerlink\" title=\"1. 配置 ssh\"></a>1. 配置 <code>ssh</code></h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &lt;your-email-address&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-添加-ssh-key\"><a href=\"#2-添加-ssh-key\" class=\"headerlink\" title=\"2. 添加 ssh-key\"></a>2. 添加 <code>ssh-key</code></h2><p>在 <code>github</code> 主页，在左侧的 <code>SSH and GPG keys</code> 中，新建 <code>SSH-key</code>，自定义一个标题，将 <code>id_rsa.pub</code> 复制的内容粘贴到 <code>key</code> 中即可。</p>\n<p><img src=\"/2021/11/09/blog/3.png\" alt=\"pic3\"></p>\n<h2 id=\"3-配置账号和密码\"><a href=\"#3-配置账号和密码\" class=\"headerlink\" title=\"3. 配置账号和密码\"></a>3. 配置账号和密码</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &lt;your-user-name&gt;</span><br><span class=\"line\">$ git config --global user.email &lt;your-email-address&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三、-搭建博客\"><a href=\"#三、-搭建博客\" class=\"headerlink\" title=\"三、 搭建博客\"></a>三、 搭建博客</h1><h2 id=\"1-在-github-新建仓库\"><a href=\"#1-在-github-新建仓库\" class=\"headerlink\" title=\"1. 在 github 新建仓库\"></a>1. 在 <code>github</code> 新建仓库</h2><p><img src=\"/2021/11/09/blog/4.png\"></p>\n<p>仓库名称格式： <code>用户名.github.io</code></p>\n<p>例如我的用户名是 <code>Ranbo0</code>，那么我的仓库名就要设置成 <code>Ranbo0.github.io</code></p>\n<p><img src=\"/2021/11/09/blog/5.png\"></p>\n<p>因为我已经创建过了，所以这里显示已存在。</p>\n<h2 id=\"2-修改配置文件\"><a href=\"#2-修改配置文件\" class=\"headerlink\" title=\"2. 修改配置文件\"></a>2. 修改配置文件</h2><p>在 <code>hexo</code> 根目录下有个配置文件 <code>_config.yml</code> ，修改其中的 <code>deploy</code> ，表示每次更新博客时上传的仓库。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: git@github.com:Ranbo0/Ranbo0.github.io.git</span><br><span class=\"line\">  branch: main</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/11/09/blog/6.png\"></p>\n<p>其中 <code>repository</code> 和 <code>branch</code> 根据自己的仓库设置。</p>\n<h2 id=\"3-hexo-基本命令\"><a href=\"#3-hexo-基本命令\" class=\"headerlink\" title=\"3. hexo 基本命令\"></a>3. <code>hexo</code> 基本命令</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;&lt;blog-name&gt;&quot;</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">&quot;&lt;page-name&gt;&quot;</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo g <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class=\"line\">hexo s <span class=\"comment\">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#部署到GitHub</span></span><br><span class=\"line\">hexo d <span class=\"comment\">#部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo h  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo v  <span class=\"comment\">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-创建第一篇博客\"><a href=\"#4-创建第一篇博客\" class=\"headerlink\" title=\"4. 创建第一篇博客\"></a>4. 创建第一篇博客</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;my first blog&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/11/09/blog/8.png\"></p>\n<p>然后会在 <code>source/_posts</code> 下创建一个名为 <code>my-first-blog.md</code> 的文件，修改该文件后即可将文件上传到自己的博客上了。</p>\n<p><img src=\"/2021/11/09/blog/9.png\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2021/11/09/blog/7.png\"></p>\n<p>其中的 <code>http://localhost:4000</code> 是预览页面，可以在达到自己的效果之后再提交到 <code>github</code> 上。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p>每次提交之前可以先 <code>hexo clean</code> ，然后再执行 <code>hexo g</code> 和 <code>hexo d</code> 。</p>\n<p><img src=\"/2021/11/09/blog/10.png\"></p>\n<p>如图所示，即成功上传。</p>\n<ul>\n<li><p>当执行 <code>hexo d</code> 时出现 <code>ERROR Deployer not found: git</code> 的报错信息时，再次安装<code>hexo-deployer-git</code>：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>以上即是搭建自己的博客的教程。</p>\n<hr>\n<p>下面介绍如何渲染自己的博客。首先要安装 <code>nexT</code> ：</p>\n<h1 id=\"四、-安装主题\"><a href=\"#四、-安装主题\" class=\"headerlink\" title=\"四、 安装主题\"></a>四、 安装主题</h1><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"五、-启用主题及相关配置\"><a href=\"#五、-启用主题及相关配置\" class=\"headerlink\" title=\"五、 启用主题及相关配置\"></a>五、 启用主题及相关配置</h1><h2 id=\"1-启用主题\"><a href=\"#1-启用主题\" class=\"headerlink\" title=\"1. 启用主题\"></a>1. 启用主题</h2><p>打开 <code>hexo</code> 的 <code>_config.yml</code> 文件，找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>\n<p><img src=\"/2021/11/09/blog/11.png\"></p>\n<h2 id=\"2-验证主题安装成功\"><a href=\"#2-验证主题安装成功\" class=\"headerlink\" title=\"2. 验证主题安装成功\"></a>2. 验证主题安装成功</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>\n<p>若此时的界面与未安装 <code>next</code> 时的界面相同，或者全部是纯文本则表示主题安装失败，需要重新安装。</p>\n<h2 id=\"3-主题设置\"><a href=\"#3-主题设置\" class=\"headerlink\" title=\"3. 主题设置\"></a>3. 主题设置</h2><p><code>Scheme</code> 是 <code>NexT </code>提供的一种特性，借助于 <code>Scheme</code>，<code>NexT </code>为你提供多种不同的外观。同时，几乎所有的配置都可以 在 <code>Scheme </code>之间共用。目前 <code>NexT </code>支持三种 <code>Scheme</code>，分别是：</p>\n<ul>\n<li><code>Muse  </code>-  默认 <code>Scheme</code>，这是 <code>NexT </code>最初的版本，黑白主调，大量留白</li>\n<li><code>Mist </code> - <code>Muse </code>的紧凑版本，整洁有序的单栏外观</li>\n<li><code>Pisces </code> - 双栏 <code>Scheme</code></li>\n<li><code>Gemini</code> - 分栏</li>\n</ul>\n<p>要修改主题，打开 <code>nexT</code> 中的 <code>_config.yml</code> 文件，找到 <code>Schemes</code> ，将想要设置的主题取消注释即可。</p>\n<p><img src=\"/2021/11/09/blog/12.png\"></p>\n<h2 id=\"4-设置语言\"><a href=\"#4-设置语言\" class=\"headerlink\" title=\"4. 设置语言\"></a>4. 设置语言</h2><p>打开 <code>hexo</code> 的 <code>_config.yml</code> 文件，找到 <code>language</code> 字段，修改为 <code>zh-CN</code> 即为简体中文， <code>zh-hk</code> 即为繁体中文， <code>en</code> 为英文等。</p>\n<h2 id=\"5-其他\"><a href=\"#5-其他\" class=\"headerlink\" title=\"5. 其他\"></a>5. 其他</h2><p>其他的设置可以根据<a href=\"http://theme-next.iissnan.com/getting-started.html\">开始使用 - NexT 使用文档 (iissnan.com)</a> 进行。</p>\n","tags":["教程"]},{"title":"八方旅人 -- 壁纸 (1920×1080)","url":"/2021/11/11/octopath/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><code>Alpyn</code></p>\n<span id=\"more\"></span>\n\n<p><img src=\"/2021/11/11/octopath/alpyn.jpg\"></p>\n<p><code>Cyrus</code></p>\n<p><img src=\"/2021/11/11/octopath/cyrus.jpg\"></p>\n<p><code>haaint</code></p>\n<p><img src=\"/2021/11/11/octopath/haaint.jpg\"></p>\n<p><code>Olberic</code></p>\n<p><img src=\"/2021/11/11/octopath/olberic.jpg\"></p>\n<p><code>Ophilia</code></p>\n<p><img src=\"/2021/11/11/octopath/ophilia.jpg\"></p>\n<p><code>Primrose</code></p>\n<p><img src=\"/2021/11/11/octopath/primrose.jpg\"></p>\n<p><code>Therion</code></p>\n<p><img src=\"/2021/11/11/octopath/therion.jpg\"></p>\n<p><code>Tressia</code></p>\n<p><img src=\"/2021/11/11/octopath/tressia.jpg\"></p>\n<hr>\n<p><code>ART1</code></p>\n<p><img src=\"/2021/11/11/octopath/art1.jpg\"></p>\n<p><code>ART2</code></p>\n<p><img src=\"/2021/11/11/octopath/art2.jpg\"></p>\n<p><code>ART3</code></p>\n<p><img src=\"/2021/11/11/octopath/art3.jpg\"></p>\n","categories":["OCTOPATH"],"tags":["OCTOPATH","paperwall"]},{"title":"【置顶】更新日志","url":"/2021/11/11/top/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>$$<br>\\LARGE{2021.11}<br>$$</p>\n<hr>\n<span id=\"more\"></span>\n\n<p>$$<br>\\Large{2021.11.12}<br>$$</p>\n<ul>\n<li>新增站内搜索功能</li>\n<li>新增点击特效</li>\n<li>新增音乐</li>\n<li>修复了搜索功能失效的问题</li>\n<li>新增音乐列表</li>\n<li>修复音乐无法点击播放的问题</li>\n<li>新增音乐全局播放</li>\n<li>新增音乐进度条</li>\n<li>新增站内页面跳转不打断音乐播放</li>\n<li>新增打赏功能</li>\n<li>更新 <code>CUDA</code> 相关博文</li>\n</ul>\n<p>$$<br>\\Large{2021.11.11}<br>$$</p>\n<ul>\n<li>修复归档导致页面崩溃的 <code>BUG</code></li>\n<li>新增评论功能</li>\n<li>新增友链</li>\n<li>上传 <code>CUDA</code> 相关博文</li>\n</ul>\n<p>$$<br>\\Large{2021.11.10}<br>$$</p>\n<ul>\n<li>修复无法正确识别图片的 <code>BUG</code></li>\n<li>新增归档功能</li>\n<li>新增标签功能</li>\n<li>新增归类功能</li>\n<li>上传 <code>JErasure</code> 库的相关博文</li>\n</ul>\n<p>$$<br>\\Large{2021.11.09}<br>$$</p>\n<ul>\n<li>创建博客</li>\n<li>新增 <code>nexT</code> 渲染模式</li>\n<li>新增了一些良性 <code>BUG</code></li>\n<li>上传第一篇博客</li>\n</ul>\n","categories":["LOG"],"tags":["logs"]},{"title":"JErasure库的相关介绍","url":"/2021/11/10/galois/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>JErasure库提供一般的RS码和CRS码两种编码方式，是基于C的纠删码的类库。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"一、Galois-Field\"><a href=\"#一、Galois-Field\" class=\"headerlink\" title=\"一、Galois Field\"></a>一、Galois Field</h1><h2 id=\"（一）基本概念\"><a href=\"#（一）基本概念\" class=\"headerlink\" title=\"（一）基本概念\"></a>（一）基本概念</h2><h3 id=\"1-1-1-域（field）\"><a href=\"#1-1-1-域（field）\" class=\"headerlink\" title=\"1.1.1 域（field）\"></a>1.1.1 域（field）</h3><p>域代表一组元素和元素间的四则运算的集合。其中，域内元素的四则运算必须满足封闭性，也就是说域内元素进行四则运算后得到的结果仍为域内元素。</p>\n<h3 id=\"1-1-2-有限域（finite-field）\"><a href=\"#1-1-2-有限域（finite-field）\" class=\"headerlink\" title=\"1.1.2 有限域（finite field）\"></a>1.1.2 有限域（finite field）</h3><p>有限域即为仅含有有限个元素的域。有限域又称作伽罗华域(Galois Field)。记为$GF$。例如，$GF(7)$的元素为0~6.</p>\n<p>有限域中必须含有加法单位元和乘法单位元。加法单位元即域中的<strong>零元</strong>，即存在元素$e$，使得域中任一元素$a$，有$e+a = a$。乘法单位元即域中的<strong>幺元</strong>，即存在元素e，使得域中任一元素$a$，有$e*a = a$。$GF(p)$的加法单位元和乘法单位元分别为0和1.</p>\n<p>此外，有限域中的每个元素还应有对应的逆元。乘法逆元与我们常见的倒数类似。即存在元素b，使得$b*a = e$，则$b$为$a$的乘法逆元。其中$e$为乘法单位元。加法逆元与我们常见的相反数类似。即存在元素$b$，使得$b+a = e$，则$b$为$a$的加法逆元。其中$e$为加法单位元。</p>\n<p>有限域中的减法和除法即为加法和乘法的逆过程。$GF(p)$的加法和乘法与实数域内的加法和乘法相似，只不过最后要模$p$。即$GF(a+b) = (a+b) \\mod p， GF(a×b) = (a×b) \\mod p$。</p>\n<p>一般而言，$p$应为质数，因为如果$p$非质数，则可能有一些元素找不到乘法逆元。例如$GF(9)$中，元素3找不到$GF(9)$中的一个元素$a$使$3\\times a \\mod p = 1$，即3没有乘法逆元。</p>\n<h2 id=\"（二）-GF-2-w\"><a href=\"#（二）-GF-2-w\" class=\"headerlink\" title=\"（二）$GF(2^w)$\"></a>（二）$GF(2^w)$</h2><h3 id=\"1-2-1-GF-2-w\"><a href=\"#1-2-1-GF-2-w\" class=\"headerlink\" title=\"1.2.1 $GF(2^w)$\"></a>1.2.1 $GF(2^w)$</h3><p>$GF(2^w)$上的加法运算和乘法运算不使用一般的加法和乘法，而是使用多项式的计算。</p>\n<h3 id=\"1-2-2-多项式计算\"><a href=\"#1-2-2-多项式计算\" class=\"headerlink\" title=\"1.2.2 多项式计算\"></a>1.2.2 多项式计算</h3><p>$GF(2^w)$上的多项式计算中，多项式的系数为1或0，即只能取$GF(2)$上的元素；当进行加法运算时，合并同类项时，不是一般的系数相加，而是进行异或计算，且加法和减法的操作一致。例如：<br>$$<br>(x^3+x^2)+(x^4+x^2)=x^4+x^3<br>$$</p>\n<p>$GF(2^w)$上的多项式的最高次不超过$w$。例如，在$GF(2^3)$中，$f_1(x)=x^2+1$为$GF(2^3)$的多项式，$f_2(x)=x^3+x^2+1$则不是$GF(2^3)$的多项式。</p>\n<p>但是，多项式的加法计算后的结果一定仍为域中多项式，而对于多项式乘法，若直接按一般的多项式乘法计算的计算结果则可能不再是域中的多项式。与$GF(p)$类似，需要找到一个多项式对其取模，使之仍然为域中多项式。因此，提出本原多项式的概念。</p>\n<h3 id=\"1-2-3-本原多项式-质多项式-text-primitive-polynomial\"><a href=\"#1-2-3-本原多项式-质多项式-text-primitive-polynomial\" class=\"headerlink\" title=\"1.2.3 本原多项式/质多项式($\\text{primitive polynomial}$)\"></a>1.2.3 本原多项式/质多项式($\\text{primitive polynomial}$)</h3><p>质多项式与质数的概念类似，质多项式即为不能表示成除幺元对应的多项式与该多项式以外的其他多项式的乘积，即<strong>不能再进行因式分解的多项式</strong>。例如，在$GF(2^4)$中，$f(x) = x^4 + 1$不是$GF(2^4)$上的质多项式，因为$f(x) = (x^2 + 1) × (x^2 + 1)$。$g(x) = x^4 + x + 1$是$GF(2^4)$上的质多项式，因为它不可再分解。</p>\n<p>以$GF(2^3)$为例，指数小于3的多项式一共有8个，分别是$0，1，x，x+1，x^2，x^2+1，x^2+x，x^2+x+1$，一共有8个多项式。其对应的系数分别可以表示为<code>000</code>，<code>001</code>，<code>010</code>，<code>011</code>，<code>100</code>，<code>101</code>，<code>110</code>，<code>111</code>，若用十进制表示，则正好为<code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>7</code>。这说明0~7与8个多项式之间有着必然的映射关系，每个多项式会对应一个值。对于$GF(2^3)$，取素多项式$f(x) = x^3+x+1$，则$x+1$的乘法逆元为$x^2+x$，因为$((x+1) × (x^2+x) mod (x^3+x+1) = 1)$，也就是说即使$\\mod 8$不能构成一个有限域，但是由质多项式仍然可以为域中每个元素找到一个乘法逆元。<br>此时，多项式的乘法即可得到解决。例如，在$GF(2^3)$内：<br>$$<br>x\\times (x^2+1)=x\\times (x^2+1)\\mod (x^3+x+1)=(x^3+x)\\mod (x^3+x+1)=1<br>$$</p>\n<p> 对于多项式除法，根据$$r(x) = q(x)t(x) + s(x)$$，其中$r(x),q(x),t(x),s(x)$均为$GF(2^w)$上的多项式，$q(x)$表示$GF(2^w)$上的质多项式。易知$r(x) \\mod q(x) = s(x)$，且显然有$dim\\ s(x) &lt; dim\\ q(x)$。（$dim\\ f(x)$表示的是$f(x)$的最高次的次数）。</p>\n<p>根据上述理论，即可根据质多项式来得到$GF(2^w)$的所有元素。$GF(2^w)$中元素的生成过程如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 给定一个初始集合&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, x&#125;;</span><br><span class=\"line\"><span class=\"number\">2.</span> 将这个集合的最后一个元素乘以x。如果得到的结果的度(dim) ≥ w，则将结果 <span class=\"function\">mod <span class=\"title\">q</span><span class=\"params\">(x)</span>，将结果加入集合中</span>;</span><br><span class=\"line\"><span class=\"number\">3.</span> 重复<span class=\"number\">2</span>，直到集合中有<span class=\"number\">2</span>^w个元素。此时最后的一个元素乘以x再 <span class=\"function\">mod <span class=\"title\">q</span><span class=\"params\">(x)</span>的值必定为1.</span></span><br></pre></td></tr></table></figure>\n\n<p>举个栗子：<br>$w = 2$时，$q(x) = x^2 + x + 1$，初始集合为${0, 1, x}$，</p>\n<p>最后一个元素为$x$，乘以$x$后为$x^2$，$dim\\ (x^2) = 2$，因此要对$q(x)$取模，得$(x^2) \\mod (x^2 + x + 1) = x + 1$；此时集合更新为${0, 1, x, x+1}$；</p>\n<p>再将最后一个元素乘以$x$，为$x^2 + x$,仍需要对$q(x)$取模，得$(x^2 + x) mod (x^2 + x + 1) = 1$,结束上述过程。即$GF(2^2) = {0, 1, x, x+1}$。</p>\n<p>也就是说，只需要找到对应$GF(2^w)$上的本原多项式$q(x)$即可通过$x$代换得到$GF(2^w)$，即：<br>$$<br>GF(2^w) = GF(2)[x]/q(x)<br>$$</p>\n<p>常用的本原多项式有：</p>\n<pre><code>w = 4:   x^4 + x + 1\nw = 8:   x^8 + x^4 + x^3 + x^2 + 1\nw = 16:  x^16 + x^12 + x^3 + x + 1\nw = 32:  x^32 + x^22 + x^2 + x + 1\nw = 64:  x^64 + x^4 + x^3 + x + 1\n</code></pre>\n<p>例如，$GF(2^4)$的元素生成：($P(x) = x^4 + x + 1$)<br><img src=\"https://img-blog.csdnimg.cn/20201113002057855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"GF(2^4)的元素生成过程\"></p>\n<p>由上述计算结果，可以构建以下两个表（正表和反表)：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>i</strong></th>\n<th align=\"center\"><strong>0</strong></th>\n<th align=\"center\"><strong>1</strong></th>\n<th align=\"center\"><strong>2</strong></th>\n<th align=\"center\"><strong>3</strong></th>\n<th align=\"center\"><strong>4</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">gflog[i]</td>\n<td align=\"center\">-</td>\n<td align=\"center\">0</td>\n<td align=\"center\">1</td>\n<td align=\"center\">4</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">gfilog[i]</td>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">4</td>\n<td align=\"center\">8</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>5</strong></td>\n<td align=\"center\"><strong>6</strong></td>\n<td align=\"center\"><strong>7</strong></td>\n<td align=\"center\"><strong>8</strong></td>\n<td align=\"center\"><strong>9</strong></td>\n<td align=\"center\"><strong>10</strong></td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\">5</td>\n<td align=\"center\">10</td>\n<td align=\"center\">3</td>\n<td align=\"center\">14</td>\n<td align=\"center\">9</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">12</td>\n<td align=\"center\">11</td>\n<td align=\"center\">5</td>\n<td align=\"center\">19</td>\n<td align=\"center\">7</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>11</strong></td>\n<td align=\"center\"><strong>12</strong></td>\n<td align=\"center\"><strong>13</strong></td>\n<td align=\"center\"><strong>14</strong></td>\n<td align=\"center\"><strong>15</strong></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">6</td>\n<td align=\"center\">13</td>\n<td align=\"center\">11</td>\n<td align=\"center\">12</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">14</td>\n<td align=\"center\">15</td>\n<td align=\"center\">13</td>\n<td align=\"center\">9</td>\n<td align=\"center\">-</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>其中，<code>gflog[i]</code>表（反表）是将二进制映射成多项式，例如将5映射成多项式，即$gflog[5] = 8$,即$x^8 = 5$；<code>gfilog[i]</code>表（正表）是将多项式映射成二进制(值),例如将5(即$x^5$)映射成值，即$gfilog[5] = 6$,即$x^5 = 6$.</p>\n<p>对于乘法和除法，可以由如下方式进行：<br>$$<br>x^a\\times x^b=x^{a+b};\\<br>x^a/x^b=x^{a-b}.<br>$$</p>\n<p>因此，我们在计算可以$a×b$时，可以先得到$a = x^m, b = x^n$; 则$a\\times b = x^{m + n}, a/b = x^{m - n}$.</p>\n<p>即：先将$a，b$查找反表（gflog[i]）得到$m，n$；计算$m + n$或者$m - n$，然后基于结果查找正表（gfilog[i]）得到乘法和除法的结果。需要注意的是，在计算$m + n$和$m - n$时，若结果大于等于15或小于0，则需要对15($2^w - 1$)取模。因为0是单独存在的，在$GF(2^w)$中没有哪个元素的任意次方等于0.</p>\n<p>再举个栗子：</p>\n<p>7 × 9 = gfilog[gflog[7] + gflog[9]] = gfilog[10 + 14] = gfilog[9] = 10</p>\n<p>($7 × 9 = x^{10} × x^{14} = x^{10 + 14} = x^{24 \\mod 15} = x^9 = 10$)</p>\n<p>13 / 11 = gfilog[gflog[13] - gflog[11]] =  gfilog[13 - 7] = gfilog[6] = 12</p>\n<p>($13 / 11 = x^{13} / x^7 = x^{13-7} = x^6 = 12$)</p>\n<p>因此，构造正反表之后，可以大大简化乘法和除法的计算，可以直接通过加法和查表得到结果，而不需要再进行繁琐的取模等运算。</p>\n<h1 id=\"二、CRS码\"><a href=\"#二、CRS码\" class=\"headerlink\" title=\"二、CRS码\"></a>二、CRS码</h1><h2 id=\"（一）RS码简介\"><a href=\"#（一）RS码简介\" class=\"headerlink\" title=\"（一）RS码简介\"></a>（一）RS码简介</h2><p>介绍CRS码之前先要弄明白RS码是什么。RS码就是Reed-Solomon码，是一种<strong>MDS码</strong>。编码时将k个数据块通过一定方式编码成m个校验块，我一般把它写成<strong>RS(k, m)<strong>，</strong>最多可以容忍m个数据块失效</strong>。解码时通过m个幸存块来恢复所有的数据块。那么RS码是通过什么方式来编码和解码的呢？<br>RS码通过构造生成矩阵来编码数据块。前k×k为单位阵，后m×k为生成矩阵。编码过程即为生成矩阵与数据块进行矩阵的乘法，即得到k个数据块和m个校验块。<br><img src=\"https://img-blog.csdnimg.cn/20201113104722746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Encoding\"><br>当有<strong>不多于m个块失效</strong>时，为了恢复数据块，则取出k个幸存块对应的生成矩阵的行构成一个矩阵，对该矩阵的逆与对应的幸存块相乘即可恢复出数据块。<br>例如，数据块$D_2，D_3$和校验块$P_1$丢失，取出k个幸存块对应的生成矩阵的行，例如取出$D_1，D_4， …，D_k，P_2，P_3$，一共$k$个数据块，有：<br><img src=\"https://img-blog.csdnimg.cn/2020111310581920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Decoding_1\"><br>再将左边的子矩阵的逆乘到右侧，即有：<br><img src=\"https://img-blog.csdnimg.cn/20201113110151141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Decoding_2\"><br>此时，所有的数据块就被恢复出来了。再要恢复校验块，很简单，再进行一次编码操作即可得到所有正确的校验块了。<br>然后问题来了，RS码的编解码步骤已经清楚了，现在就只有一个待解决的问题了，那就是得找到一个合适的生成矩阵，使得该生成矩阵的任意k行都线性无关，也就是说任意k行组成的矩阵的行列式不为0，此时即可保证任意k行组成的子矩阵必定可逆。因此，在RS码中，我们一般采用 <strong>范德蒙德矩阵（Vandermonde Matrix）</strong> 作为生成矩阵，此时该矩阵的任意k行组成的子矩阵一定可逆。<br>用范德蒙德矩阵进行编码的时间复杂度为<code>O(mk)</code>，解码的时间复杂度为<code>O(k^3)</code>。<br>在利用范德蒙德矩阵编码的时候，我们可以采用对数/反对数表的方法将乘法运算转换成加法运算，并且在迦罗华域中，加法运算转换成了XOR运算。<br>显然，这种方法要比直接复制副本存储的空间开销小得多，但是解码时花费的时间有点多了。所以，基于Reed-Solomon码，又有另一种纠删码被提出 – <strong>Cauchy Reed-Solomon Code</strong>。</p>\n<h2 id=\"（二）CRS-Code简介\"><a href=\"#（二）CRS-Code简介\" class=\"headerlink\" title=\"（二）CRS Code简介\"></a>（二）CRS Code简介</h2><h3 id=\"2-2-1-Cauchy-Matrix\"><a href=\"#2-2-1-Cauchy-Matrix\" class=\"headerlink\" title=\"2.2.1 Cauchy Matrix\"></a>2.2.1 Cauchy Matrix</h3><p>Cauchy矩阵是由两个交集为空的集合构成的矩阵。具体为：</p>\n<p>令C = [c<sub>ij</sub>]<sub>m$\\times$n</sub>，有集合X = {$x_1, x_2, \\cdots, x_m$}，Y = {$y_1, y_2, \\cdots, y_n$}，且X∩Y = ∅。矩阵C中的元素$c_{ij}$满足<br>$$<br>c_{ij} = \\frac{1}{x_i + y_j}<br>$$<br>则矩阵C为Cauchy矩阵。</p>\n<p>Cauchy矩阵有一个很重要的性质，即Cauchy矩阵的任意一个子方阵必定可逆。且求逆的时间复杂度为O($n^2$)，$n$为子方阵的维数。<br>例如，对于$X = {1, 2}$，$Y = {0, 3, 4, 5, 6}$，其编解码过程如下：<br><img src=\"https://img-blog.csdnimg.cn/20201113112600996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Cauchy matrix‘s encoding and decoding\"><br>从编解码过程来看，柯西编解码最大的运算量是乘法和加法运算。柯西编解码为了降低乘法复杂度，采用了有限域上的元素都可以使用二进制矩阵表示的原理，将乘法运算和加法运算转换成了迦罗华域“<strong>与运算</strong>”和“<strong>XOR逻辑运算</strong>”，提高了编解码效率。</p>\n<p>从数学的角度来看，在迦罗华有限域中，任何一个GF($2^w$)域上的元素都可以映射到GF(2)二进制域，并且采用一个二进制矩阵的方式表示GF（$2^w$）中的元素。例如，GF（$2^3$）域中的元素可以表示成GF（2）域中的二进制矩阵：<br><img src=\"https://img-blog.csdnimg.cn/20201113113320150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"GF(2^3) to GF(2)\"><br>其中，$M(e)$的第$i$列为$V(e * 2^{i-1})$.其中$e*2^{i-1}$为$GF(2^3)$上的乘法。通过以上规则，可以得到：<br>$$<br>M(e_1) * V(e_2) = V(e_1e_2)，\\ M(e_1) * M(e_2) = M(e_1e_2) \\<br>$$<br>.<br>举个栗子：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201113113607895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"GF(2^3)的乘法转化为GF(2)的乘法\"><br>根据上述理论，将Cauchy matrix的每个元素($e$)全部替换成$M(e)$，以此替换即可将计算从$GF(2^w)$上的计算变为$GF(2)$的计算(位运算)。为了可以使两矩阵能进行乘法计算，将每个数据块并没有划分为$2^w$大小，而是划分为$w$，即将每个数据块分为$w$块。例如，对前文所述的Cauchy matrix和$GF(2^3)$，有：<br><img src=\"https://img-blog.csdnimg.cn/2020111311384323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"convert Cauchy matrix to bitmatrix\"></p>\n<h3 id=\"2-2-2-相关证明\"><a href=\"#2-2-2-相关证明\" class=\"headerlink\" title=\"2.2.2 相关证明\"></a>2.2.2 相关证明</h3><p>上述结论可以证明。证明过程如下：</p>\n<p>令$P(x)$为$GF(2)[x]$中的$L$次本原多项式。由前文介绍的Galois Field中的理论，可以得知$GF(2^L)$中的元素可以由$f(x) = \\sum_{i = 0}^{L-1}f_ix^i$表出，其中$f_i\\in GF(2)$。记列向量$$(f_1, f_2, \\cdots, f_{L-1})$$为$f(x)$的系数向量（coefficient vector）。</p>\n<p>对属于$GF(2^L)$的任意多项式$f(x)$，令$\\tau(f)$为系数向量的矩阵，其中$\\tau(f)$的第$i$列为$$x^{i-1}f(x) \\pmod {P(x)}$$的系数向量。<br>根据以上定义，有以下引理：</p>\n<p>（1）$\\tau(0)$是零矩阵；</p>\n<p>（2）$\\tau(1)$是单位矩阵；</p>\n<p>（3）$\\tau$是单射；</p>\n<p>（4）$\\tau(f) + \\tau(g) = \\tau(f+g)$；$f$和$g$是$GF(2^L)$的多项式；</p>\n<p>（5）$\\tau(f)\\tau(g) = \\tau(fg)$；$f$和$g$是$GF(2^L)$的多项式</p>\n<p>其中(1)到(3)很容易证明，这里只证明(4)和(5):<br>$$<br>x^i(f+g) = x^if + x^ig \\pmod {P(x)}<br>$$<br>其中$x^i(f + g)$表示以$\\tau(f + g)$的第$i$列为系数的多项式，$x^if$和$x^ig$表示以$\\tau(f)$和$\\tau(g)$的第$i$列为系数的多项式。显然，(4)得证。<br>令$f^{(i)}$表示$\\tau(f)$的第$i$列; 令${g_0^{(j)}, g_1^{(j)}, \\cdots, g_{L-1}^{(j)}}^T$为$\\tau(g)$的第$j$列。则有：<br>$$<br>\\sum_{i=0}^{L-1}g_i^{(j)}x^i = x^{j-1}g \\mod p(x)<br>$$<br>(其中$p(x)$为$GF(2^L)$上的质多项式，$g = g_0^{(1)}+g_1^{(1)}x + g_2^{(1)}x^2 + \\cdots + g_{L-1}^{(1)}x^{L-1}$)</p>\n<p>因$\\tau(f)\\tau(g)$的第$j$列为：<br>$$<br>\\begin{bmatrix}<br>f^{(1)} &amp; f^{(2)} &amp; \\cdots &amp; f^{(L)}<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>\\cdots &amp; g_0^{(j)} &amp; \\cdots \\<br>\\cdots &amp; g_1^{(j)} &amp; \\cdots \\<br>\\vdots &amp; \\vdots &amp; \\vdots \\<br>\\cdots &amp; g_{L-1}^{(j)} &amp; \\cdots \\<br>\\end{bmatrix}<br>$$<br>$$<br>\\begin{aligned}<br> &amp;= g_0^{(j)}f^{(1)}+g_1^{(j)}f^{(2)}+ \\cdots +g_{L-1}^{(j)}f^{(L)}\\<br>&amp;= \\sum_{i=0}^{L-1}g_i^{(j)}f^{(i+1)}<br>\\end{aligned}<br>$$</p>\n<p>这就是下面这个的多项式的系数向量：<br>$$<br>\\sum_{i=0}^{L-1}g_i^{(j)}(x^if) = f\\sum_{i=0}^{L-1}g_i^{(j)}x^i = x^{j-1}fg \\mod p(x)<br>$$<br>即：$\\tau(f)\\tau(g)$的第j列与$\\tau(fg)$的第j列相同</p>\n<p>即：$\\tau(f)\\tau(g)=\\tau(fg)$</p>\n<p>也就是说，将$GF(2^w)$映射成$\\tau(GF(2^w))$后，仍然有加法和乘法的不变性，即:<br>$$<br>M(e_1) * M(e_2) = M(e_1e_2)<br>$$</p>\n<p>若将$M(e_2)$的第一列提取出来，即为：<br>$$<br>M(e_1) * V(e_2) = V(e_1e_2)<br>$$</p>\n<p>至此，前面的理论已完全证毕。</p>\n<p>现在再来证明Cauchy matrix的求逆过程可以在$O(n^2)$的时间复杂度内完成。</p>\n<p>对于Cauchy矩阵的任意一个子方阵$C = [c_{ij}]<em>{n\\times n}$:<br>$$<br>\\begin{bmatrix}<br>\\frac{1}{x_1+y_1} &amp; \\frac{1}{x_1+y_2} &amp; \\cdots &amp; \\frac{1}{x_1+y_n}  \\[10pt]<br>\\frac{1}{x_2+y_1} &amp; \\frac{1}{x_2+y_2} &amp; \\cdots &amp; \\frac{1}{x_2+y_n} \\[10pt]<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\[10pt]<br>\\frac{1}{x_n+y_1} &amp; \\frac{1}{x_n+y_2} &amp; \\cdots &amp; \\frac{1}{x_n+y_n}<br>\\end{bmatrix}<br>$$<br>其行列式<br>$$<br>\\det C = \\frac{\\prod</em>{i&lt;j}(x_i-x_j)\\prod_{i&lt;j}(y_i-y_j)}{\\prod_{i,j = 1}^n(x_i+y_j)}<br>$$<br>令$C^{-1} = [d_{ij}]$，则有</p>\n<p>$$<br>d_{ij} = (-1)^{i+j}\\frac{\\det C_{ji}}{\\det C_j}<br>$$<br>其中$c_{ji}$表示删除了第$j$行和第$i$列的矩阵$C$。令<br>$$<br>\\begin{align}<br>a_k &amp;= \\prod_{i&lt;k}(x_i-x_k)\\prod_{k&lt;j}(x_k-x_j)\\<br>b_k &amp;= \\prod_{i&lt;k}(y_i-y_k)\\prod_{k&lt;j}(y_j-y_k)\\<br>c_k &amp;= \\prod_{i=1}^n(x_k+y_i)\\<br>f_k &amp;= \\prod_{i=1}^n(y_k+x_i)<br>\\end{align}<br>$$<br>因此，有：</p>\n<p>$$<br>\\begin{align}<br>\\det C &amp;= \\frac{\\prod_{k=1}^na_kb_k}{\\prod_{k=1}^ne_kf_k}\\<br>\\det C_{ji} &amp;= \\frac{\\det C e_jf_i}{a_jb_i(x_j+y_i)}<br>\\end{align}<br>$$<br>因此：</p>\n<p>$$<br>d_{ij} = (-1)^{i+j}\\frac{e_jf_i}{a_jb_i(x_j+y_i)}<br>$$<br>所以$4n$个未知量$a_k, b_k, c_k, f_k$可以在$O(n^2)$的时间复杂度内被解出，而$d_{ij}$则可由上述公式在$O(1)$的时间复杂度得到，因此，Cauchy矩阵的求逆过程可以在$O(n^2)$的时间复杂度内得到。</p>\n<h1 id=\"三、JErasure库源码分析\"><a href=\"#三、JErasure库源码分析\" class=\"headerlink\" title=\"三、JErasure库源码分析\"></a>三、JErasure库源码分析</h1><h2 id=\"（一）Galois-c-Galois-h\"><a href=\"#（一）Galois-c-Galois-h\" class=\"headerlink\" title=\"（一）Galois.c/Galois.h\"></a>（一）Galois.c/Galois.h</h2><p>这两个文件中定义的函数比较简单。首先：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> prim_poly[<span class=\"number\">33</span>]; <span class=\"comment\">//对应的w的各个质多项式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> mult_type[<span class=\"number\">33</span>]; <span class=\"comment\">//对于不同的w采用不同的乘法计算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nw[<span class=\"number\">33</span>];\t\t  <span class=\"comment\">//存放的是2^w的值，nwm1是2^w-1的值，即GF(2^w)的最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_log_tables[<span class=\"number\">33</span>];  <span class=\"comment\">//各个w(1~30)的反表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_ilog_tables[<span class=\"number\">33</span>]; <span class=\"comment\">//各个w(1~30)的正表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_mult_tables[<span class=\"number\">33</span>]; <span class=\"comment\">//各个w(1~30)的乘法表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_div_tables[<span class=\"number\">33</span>];  <span class=\"comment\">//各个w(1~30)的除法表</span></span><br></pre></td></tr></table></figure>\n<p>以上是Galois.c中定义的一系列表，这些表将会在之后进行构造。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_create_log_tables</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//创建w的正反表，且将正表复制了两份，以便构建乘法表和除法表，然后将正表的初始位置(galois_log_tables[w][0]置为第二个副本的起始位置)，返回0表示构建成功，返回1表示失败</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_logtable_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查正反表计算x*y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_logtable_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查正反表计算x/y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_create_mult_tables</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//构建大小为nw[w] * nw[w]的乘法表和除法表</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_ilog</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//求value对应的二进制的值，即x^value对应的数值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_log</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//求value对应的多项式，即value对应的x^i的i值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_shift_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//移位乘法，不需要任何表即可实现，但需要w次乘2，w次判断。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//对于x*y，先计算出y*2, y*2^2, y*2^3, ..., y*2^w-1的值，然后将x化为二进制，对x的第i位为1的，取出y*2^i进行异或得到结果。</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_multtable_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查乘法表求x*y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_invert_binary_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> *inv, <span class=\"keyword\">int</span> rows)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用初等变换法计算二进制矩阵mat的逆矩阵，mat的每一个元素表示一行，应为w，即w = row，若不可逆则停止运行程序</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_inverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//若w = 23~32，用移位，否则直接用galois_single_multiply计算1/x</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_shift_inverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//以移位的方式求y的倒数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//先由y得到mat2[w] = &#123;y, y*2, y*2^2, ..., y*2^w-1&#125;，通过galois_invert_binary_matrix函数得到mat2[w]的逆矩阵inv，inv[0]即为1/y的值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_single_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//计算x*y，对于不同的w采用不同的乘法策略：</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/********************************</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 1~9: 构造乘法表，查乘法表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 10~22: 构建正反表，查正反表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 23~31: 用移位乘法</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 32: 用裂乘</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> ********************************/</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_single_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//计算a/b，对于不同的w采用不同的除法策略：</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/********************************</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 1~9: 构造除法表，查除法表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 10~22: 构建正反表，查正反表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 23~32: 先得到b的倒数(galois_inverse(b, w))，再用galois_single_multiply函数计算(分为w = 23~31和w = 32的两种策略)</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> ********************************/</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_shift_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//利用galois_shift_inverse函数得到b的倒数，再利用移位乘法得到a/b的值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_multtable_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查除法表得x/y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_create_split_w8_tables</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//创建裂乘表</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_split_w8_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//裂乘</span></span></span><br></pre></td></tr></table></figure>\n<p>其中，裂乘的思路如下：<br>对于$x\\times y$，以$GF(2^{32})$为例，$x$和$y$均为域内元素，则$x$和$y$可表示成：<br>$$<br>x = x_0+2^8\\times x_1+2^{2\\times 8}\\times x_2+2^{3\\times 8}\\times x_3 \\<br>y = y_0+2^8\\times y_1+2^{2\\times 8}\\times y_2+2^{3\\times 8}\\times y_3<br>$$</p>\n<p>其中$x_i$和$y_i$均为unit8_t型数据，$i \\in {0, 1, 2, 3}$.<br>则：<br>$$<br>\\begin{aligned}<br>x\\times y &amp;= ( x_0+2^8\\times x_1+2^{2\\times 8}\\times x_2+2^{3\\times 8}\\times x_3)\\times (y_0+2^8\\times y_1+2^{2\\times 8}\\times y_2+2^{3\\times 8}\\times y_3)\\<br>&amp;=x_0y_0\\<br>&amp;+\\ 2^8\\times (x_0y_1+x_1y_0)\\<br>&amp;+\\ 2^{2 \\times 8}\\times (x_0y_2+x_1y_1+x_2y_0)\\<br>&amp;+\\ 2^{3 \\times 8}\\times (x_0y_3+x_1y_2+x_2y_1+x_3y_0)\\<br>&amp;+\\ 2^{4 \\times 8}\\times (x_1y_3+x_2y_2+x_3y_1)\\<br>&amp;+\\ 2^{5 \\times 8}\\times (x_2y_3+x_3y_2)\\<br>&amp;+\\ 2^{6 \\times 8}\\times (x_3y_3)<br>\\end{aligned}<br>$$<br>因此，设$\\alpha$为unit32_t类型数中只有低$8$位的任意数字，那么根据上述$x\\times y$的拆分结果可以归结为<br>$$<br>\\alpha \\times \\alpha, \\alpha \\times (\\alpha &lt;&lt; 8), \\alpha \\times (\\alpha&lt;&lt;16),\\alpha \\times (\\alpha&lt;&lt;24),<br>$$</p>\n<p>$$<br> (\\alpha &lt;&lt; 8)\\times (\\alpha&lt;&lt;24),(\\alpha &lt;&lt; 16)\\times (\\alpha&lt;&lt;24),(\\alpha &lt;&lt; 24)\\times (\\alpha&lt;&lt;24)<br>$$</p>\n<p>一共7种运算。每一种运算可以用一个乘法表表示，每个乘法表大小为$2^8\\times 2^8\\times 4\\ Bytes$.</p>\n<p>以上为Galois field上的一些基本运算。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_region_xor</span><span class=\"params\">(<span class=\"keyword\">char</span> *r1,         <span class=\"comment\">/* Region 1 */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"keyword\">char</span> *r2,         <span class=\"comment\">/* Region 2 */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"keyword\">char</span> *r3,         <span class=\"comment\">/* Sum region (r3 = r1 ^ r2) */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"keyword\">int</span> nbytes)</span></span>;      <span class=\"comment\">/* Number of bytes in region */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_w08_region_multiply</span><span class=\"params\">(<span class=\"keyword\">char</span> *region,       <span class=\"comment\">/* Region to multiply */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> multby,       <span class=\"comment\">/* Number to multiply by */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> nbytes,       <span class=\"comment\">/* Number of bytes in region */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">char</span> *r2,         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">/* If r2 != NULL, products go here.Otherwise region is overwritten */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> add)</span></span>;         </span><br><span class=\"line\"><span class=\"comment\">/* If (r2 != NULL &amp;&amp; add) the produce is XOR&#x27;d with r2 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_w16_region_multiply</span><span class=\"params\">(<span class=\"keyword\">char</span> *region,       <span class=\"comment\">/* Region to multiply */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> multby,       <span class=\"comment\">/* Number to multiply by */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> nbytes,       <span class=\"comment\">/* Number of bytes in region */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">char</span> *r2,         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">/* If r2 != NULL, products go here. Otherwise region is overwritten */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> add)</span></span>;         </span><br><span class=\"line\"><span class=\"comment\">/* If (r2 != NULL &amp;&amp; add) the produce is XOR&#x27;d with r2 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_w32_region_multiply</span><span class=\"params\">(<span class=\"keyword\">char</span> *region,       <span class=\"comment\">/* Region to multiply */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> multby,       <span class=\"comment\">/* Number to multiply by */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> nbytes,       <span class=\"comment\">/* Number of bytes in region */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">char</span> *r2,         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">/* If r2 != NULL, products go here. Otherwise region is overwritten */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">int</span> add)</span></span>;         </span><br><span class=\"line\"><span class=\"comment\">/* If (r2 != NULL &amp;&amp; add) the produce is XOR&#x27;d with r2 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述三个函数均为将region中各个元素乘以multby</span></span><br><span class=\"line\"><span class=\"comment\">// 1. r2 == NULL,则将结果写入region，结束</span></span><br><span class=\"line\"><span class=\"comment\">// 2. r2 != NULL 且 add is false,则将结果写入r2</span></span><br><span class=\"line\"><span class=\"comment\">// 3. r2 != NULL 且 add is true,将结果与r2异或再写入r2</span></span><br></pre></td></tr></table></figure>\n<p>以上四个函数为域内乘法，第一个表示将两个等大的数组$r_1$和$r_2$按元素进行异或，将结果置入$r_3$中。后面3个函数主要用来求点积，具体的实现步骤已经标注在上面的注释中了，点积的概念将在之后介绍到。</p>\n<h2 id=\"（二）JErasure-c-JErasure-h\"><a href=\"#（二）JErasure-c-JErasure-h\" class=\"headerlink\" title=\"（二）JErasure.c/JErasure.h\"></a>（二）JErasure.c/JErasure.h</h2><h3 id=\"3-2-1-函数的参数介绍\"><a href=\"#3-2-1-函数的参数介绍\" class=\"headerlink\" title=\"3.2.1 函数的参数介绍\"></a>3.2.1 函数的参数介绍</h3><p>在分析函数功能之前，先弄明白这两个文件中定义的函数的参数。</p>\n<p>$K$ = 数据块数量</p>\n<p>$M$ = 校验块(coding devices)数量</p>\n<p>$W$ = 字长</p>\n<p>$data_ptrs[][]$ = 包含$k$个指向大小为size bytes的数据的指针的数组，即数据块指针，$size$必须是sizeof(long)的整数倍</p>\n<p>$coding_ptrs[][]$ = 指向编码数据（大小为字节）的m个指针数组，即校验块指针</p>\n<p>$packetsize$ = 使用bitmatrix编码的编码块(coding block)大小</p>\n<p>$Matrix[]$ = 包含$k\\times m$个整数(integer)的数组，即编码矩阵，其中$i$行$j$列元素为$matrix[i\\times k+j]$</p>\n<p>$Bitmatrix[]$ = 包含$kw \\times mw$个整数(integer)的数组，其中$i$行$j$列元素为$bitmatrix[i\\times kw+j]$</p>\n<p>$Erasures[]$ = 已删除的设备(devices)(块)的$id$的数组，用于记录哪些块丢失<br>        $id∈[0, k+m-1]$<br>        $id∈[0, k-1]：数据块id$<br>        $id∈[k, k+m-1]：编码块(校验块)id$<br>        $例如：erasures[0] = 0;$  //第$0$个块丢失<br>               $erasures[1] = 3;$ //第$3$个块丢失<br>               $erasures[2] = -1;$ //结束标志</p>\n<p>$Operation[op][]$ = 包含5个整数的数组(五元组)<br>    $4 : 进行操作 - 0表示复制，1表示异或$<br>    $0 : 源设备(device)[0,k+m-1](operation[op][0] = -1表示结束)$<br>    $1 : 源数据包(packet)[0,w-1]$<br>    $2 : 目标设备[0,k+m-1]$<br>    $3 : 目标数据包[0,w-1]$</p>\n<p>我这里只介绍各个接口的实现和作用，各位最好还是对照源码来理解各个参数的含义。</p>\n<h3 id=\"3-2-2-位矩阵编解码的时空优化方案\"><a href=\"#3-2-2-位矩阵编解码的时空优化方案\" class=\"headerlink\" title=\"3.2.2 位矩阵编解码的时空优化方案\"></a>3.2.2 位矩阵编解码的时空优化方案</h3><p>因为位矩阵的大小变成了$kw\\times mw$，比之前的矩阵大了$w^2-1$倍，空间利用率极低。而且在编码校验块的时候，中间可能会有大量的XOR操作是重复的，例如<br>$$<br>P_{1,1}=D_{1,1} \\otimes D_{1,2};\\<br>    P_{1,2}=D_{1,1} \\otimes D_{1,2} \\otimes D_{2,2};\\<br>    P_{2,1}=D_{1,1} \\otimes D_{2,2} \\otimes D_{3,1}<br>$$<br>因此，可以由$$P_{1,2}=P_{1,1} \\otimes D_{2,2} \\P_{2,1}=P_{1,2}\\otimes D_{2,2}\\otimes D_{3,1}$$来减少XOR次数，一般而言，$kw$和$mw$较大，所以以这种方式来减少XOR次数是可以减少编解码时间的。</p>\n<p>刚刚那个栗子只减少了1次XOR操作，看起来8太行。现在来举个好一点的栗子：<br><img src=\"https://img-blog.csdnimg.cn/20201113153306999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\"><br>由上面的图上所示，按照位矩阵的XOR操作得到校验块，可以得到：<br><img src=\"https://img-blog.csdnimg.cn/20201113153439304.png#pic_center\"><br>但是很显然，中间有大量的XOR操作可以重复利用。如果将其重复的结果进行分类，则可以有以下结果：<br><img src=\"https://img-blog.csdnimg.cn/20201113153729783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\"><br>很显然，这次是大大的减少所需的XOR操作。</p>\n<p>以这种思路，JErasure库给出了两种方式来分别实现提高空间利用率和进一步减少XOR的操作数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> **<span class=\"title\">jerasure_dumb_bitmatrix_to_schedule</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//将bitmatrix转换为一系列操作。简单粗暴。</span></span><br><span class=\"line\"><span class=\"comment\">//返回一个operations[][]数组，具体实现方式为：</span></span><br><span class=\"line\"><span class=\"comment\">//若bitmatrix[index] == 1，则计算得到当前bitmatrix位置对应的数据块位置，如果在该行是第一个bitmatrix[index] == 1，则置operation为0(copy)，否则为1(XOR)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> **<span class=\"title\">jerasure_smart_bitmatrix_to_schedule</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 采用与上一函数类似的方法，不过使用之前的结果来计算新的点积。</span></span><br></pre></td></tr></table></figure>\n<p>这两个函数都是将位矩阵(bitmatrix)转化为了调度(schedule)，既减少空间开销，也减少了XOR次数。<br>先来分析第一个函数：(dumb)<br>其实就是在模拟位矩阵与数据包的矩阵乘法过程。例如：<br><img src=\"https://img-blog.csdnimg.cn/2020111315183021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\"><br>例如: $$C_{11}=D_{11} \\otimes D_{21} \\otimes D_{22} \\otimes D_{33}\\otimes D_{41} \\otimes D_{42} \\otimes D_{43} \\otimes D_{52}$$<br>$jerasure_dumb_bitmatrix_to_schedule$即模拟$D_{11}, \\cdots, D_{52}$的操作，且每个operation元素对应了一个源块和目标块的位置，以及要进行的操作。<br>例如，$D_{11}$对应的源块即为$(1,1)$，目标块$C_{11}$即为$(1,1)$，因为$D_{11}$在第一个位置上，所以操作为复制(copy)，即为$(0)$，因此，$D_{11}$对应的五元组为$(1,1,1,1,0)$.<br>再例如，$D_{21}$对应的源块即为$(2,1)$，目标块$C_{11}$即为$(1,1)$，因为$D_{21}$不在第一个位置上，也就是说之前已经开始计算异或结果了，所以此时操作为异或(XOR)，即为$(1)$，代表XOR $D_{21}$，因此，$D_{11}$对应的五元组为$(2,1,1,1,1)$.</p>\n<p>现在来分析第二个函数：(smart)<br>前面那个函数只是开胃菜，这个函数才是对位运算的大大优化。基本思路与上一函数类似，但是这个会使用之前计算过的XOR结果(点积)来编码新的校验块。<br>下面是这种中间结果复用的实现方式：</p>\n<p>先定义一些记号，以便后续说明：<br>$\\text{from[]含有r个元素，初始置-1}$</p>\n<p>$\\text{diff[]含r个元素}，\\text{diff[i]表示Mi中1的数量}$</p>\n<p>$\\text{flink[]和 blink[]用于定位top，top用于找当前待计算的校验块}$</p>\n<p>$\\text{bestdiff记录当前最小的diff[i]的值}$</p>\n<p>$\\text{bestrow记录当前bestdiff对应的diff[i]的 i的值}$</p>\n<p>实现步骤：<br>假定$M$为$bitmatrix$，$V$为输入的数据块，$U$为生成的校验块，$notdone$代表待生成的校验块$id$的集合，初始为$0$ ~ $mw-1$，则步骤如下:</p>\n<pre><code>1. 选择未计算的校验块的packet且diff[i]最小的 i，即找到i∈notdone且diff[i]最小\n2. 若from[i] = -1, 则令operation[op]的元素为M[i, j] = 1的所有对应的数据块;\n   若from[i] ≠ -1, 则令operation[op]的第一个元素为校验块from[i]，之后的元素为第from[i]行与i行相异的bitmatrix中的元素对应的数据块\n3. 从notdone中删除i\n4. 对于notdone中的任一元素j，计算第j行与第i行中相异的元素的数量c，令x = c + 1，若x &lt; diff[j]，则diff[j] = x，from[j] = i\n</code></pre>\n<p>也就是说，在某一次计算中，如果$from[i] != -1$，则说明第$i$个校验块的计算中用前面的计算过的结果来计算第i个校验块比直接进行矩阵乘法用到的XOR数要少，如果$from[i] == -1$，则说明用前面的结果计算该校验块不如直接计算来的快，就直接从$bitmatrix$中进行异或运算。</p>\n<p>效率分析：<br>例如，在解码过程中，要计算得到$D_0$和$D_1$，通过一般的矩阵乘法计算，一共需要124次XORs。但是，如果按照上述方案：</p>\n<ol>\n<li>找到含有最少的1的一行(记为第$i$行)，即计算$D_{1,3}$对应的一行，一共有8个1，因此共7次XORs。</li>\n<li>计算其他9行(记为第$j$行)与$D_{1,3}$对应的$bitmatrix$的行中相异元素的数量，如果第$j$行中1的数量小于刚才计算出的数量+1，说明由第$j$行计算块得到结果需要的XOR数量多于由第$j$行计算块得到结果需要的XOR数量，此时将$from[j]$置为$i$，即第$j$行的XOR数量由第$i$行的结果来得到比当前方法更快。</li>\n<li>重复之，直到计算得到了所有的块。<br><img src=\"https://img-blog.csdnimg.cn/20201113154800579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\"><br>根据上述理论分析，可以得出以下计算步骤：<br><img src=\"https://img-blog.csdnimg.cn/20201113155916771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\"><br>此时一共需要46次XORs操作。相比之前的124次XORs，这种方法得到了大幅优化。</li>\n</ol>\n<h3 id=\"3-2-3-无返回值-void-的函数\"><a href=\"#3-2-3-无返回值-void-的函数\" class=\"headerlink\" title=\"3.2.3 无返回值(void)的函数\"></a>3.2.3 无返回值(void)的函数</h3><p>接下来是几个无返回值的函数，比较简单，所以拿出来放在一块儿分析了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_do_parity</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> *parity_ptr, <span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 由data_ptrs直接进行XOR操作生成校验块，结果放入parity_ptr中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_matrix_encode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 按常规方式编码，w必须是8，16，32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_bitmatrix_encode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 按常规方式对位矩阵编码，w ∈ [1, 32] and w ∈ N*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_schedule_encode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> **schedule,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用jerasure_smart_bitmatrix_to_schedule()或者jerasure_dumb_bitmatrix_to_schedule()进行编码，具体方案由schedule[][]确定</span></span><br></pre></td></tr></table></figure>\n<p>没有什么难懂的地方，我根据自己的理解加了两句注释，大家看看代码也很容易就看懂了。</p>\n<h3 id=\"3-2-4-返回整数-integer-的函数\"><a href=\"#3-2-4-返回整数-integer-的函数\" class=\"headerlink\" title=\"3.2.4 返回整数(integer)的函数\"></a>3.2.4 返回整数(integer)的函数</h3><p>这种返回整数的函数都是值返回$0$和$-1$的，返回$0$说明这个函数完整的进行了操作，返回成功的标志；返回$-1$说明参数有误，中途中断，返回失败的标志。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_matrix_decode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> row_k_ones, <span class=\"keyword\">int</span> *erasures,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>$k$表示数据块，$m$表示校验块，$matrix$表示生成矩阵，$row_k_ones$用于记录编码的第一行是否为全1，用于优化，$data_ptrs$表示指向数据块的指针，$coding_ptrs$表示指向校验块的指针，$erasures$记录哪些块失效，$size$表示块大小。<br>这个函数表示创建$GF(2^w)$上的解码矩阵进行解码，且最终会丢弃解码矩阵。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_bitmatrix_decode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">int</span> *bitmatrix, <span class=\"keyword\">int</span> row_k_ones, <span class=\"keyword\">int</span> *erasures,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>表示创建$GF(2)$上的矩阵（位矩阵）进行解码，参数同上。$packetsize$是使用位矩阵进行编解码时一个$packet$的大小。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_schedule_decode_lazy</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix, <span class=\"keyword\">int</span> *erasures,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize, <span class=\"keyword\">int</span> smart)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>若$smart == 1$，则采用$jerasure_smart_bitmatrix_to_schedule()$来创建调度（schedule），否则采用$jerasure_smart_bitmatrix_to_schedule()$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_make_decoding_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> *erased, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">int</span> *decoding_matrix, <span class=\"keyword\">int</span> *dm_ids)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>创建解码矩阵，但是不解码，解码矩阵存放在$decoding_matrix$中，$dm_ids$含有$k$个整数，即用这$k$个存活块来构建解码矩阵，最终生成的$decoding_matrix$含有$k\\times k$个整数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_make_decoding_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> *erased, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">int</span> *decoding_matrix, <span class=\"keyword\">int</span> *dm_ids)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>同上，创建解码位矩阵，但是不解码，解码矩阵存放在$decoding_matrix$中，$dm_ids$含有$kw$个整数，即用这$kw$个存活块来构建解码矩阵，最终生成的$decoding_matrix$含有$kw\\times kw$个整数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">jerasure_erasures_to_erased</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> *erasures)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>将$erasures[]$转换成$erased[]$返回，其中$erased[]$标识了哪些位置上的 $packet$不可用。例如$erased[2] = 1$说明第$2$个$packet$不可用（从第$0$个$packet$开始计数）。举个栗子：<br>若$$erasures[] = {0,2,3}$$则$$ erased[] = {1,0,1,1} $$</p>\n<h3 id=\"3-2-5-求点积（dot-product）的函数\"><a href=\"#3-2-5-求点积（dot-product）的函数\" class=\"headerlink\" title=\"3.2.5 求点积（dot product）的函数\"></a>3.2.5 求点积（dot product）的函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_matrix_dotprod</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix_row,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">int</span> *src_ids, <span class=\"keyword\">int</span> dest_id,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>简单来说，就是将生成矩阵（编码矩阵/解码矩阵）的一行元素与数据块/幸存块相乘（求点积）。</p>\n<p>数据块/幸存块的id存放在$src_ids$中，例如：<br><img src=\"https://img-blog.csdnimg.cn/20201117112501820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"dot_product\"><br>$D_{1,1}$的id为$0$，$D_{4,3}$的id为$12$，$C_{1,1}$的id为$16$等。</p>\n<p><font color=#FF0000>*<strong>注意：此处为了简单起见，给出的例子全部是以$1$开始计算id的，而一般情况下，应该从$0$开始。例如将上述$D_{1\\to5}$和$C_{1\\to2}$换成$D_{0\\to4}$和$C_{0\\to1}$，则$D_{0,0}$的id是$0$，$D_{4,3}$的id是$11$等。</strong></font></p>\n<p>编码/解码生成的块的id存放在$dest_id$中。若$src_ids = null$，则说明是在编码过程中，直接利用$data_ptrs$计算点积即可，若$src_ids\\ne null$，则说明是在解码过程中，则需要从$data_ptrs$和$coding_ptrs$中得到对应的数据块/幸存块再计算点积。</p>\n<p>该函数的对乘法计算进行了稍微的优化工作。因为点击计算需要$GF(2^w)$的乘法和加法，所以它会首先计算$matrix$中为$0$或$1$对应的块，然后再计算其他块，以简化计算的复杂度。例如：<br>$$<br>\\begin{bmatrix}<br>\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\<br>\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\<br>\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\<br>1 &amp; 3 &amp; 0 &amp; 2 &amp; 1 &amp; 0 &amp; 3 &amp; 7 \\<br>\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\<br>\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\<br>\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots<br>\\end{bmatrix}<br>\\begin{bmatrix}<br>D_1 \\[8pt]<br>D_2 \\[8pt]<br>D_3 \\[8pt]<br>D_4 \\[8pt]<br>D_5 \\[8pt]<br>D_6 \\[8pt]<br>D_7 \\[8pt]<br>D_8<br>\\end{bmatrix}=<br>\\begin{bmatrix}<br>\\cdots \\[8pt]<br>\\cdots \\[8pt]<br>\\cdots \\[8pt]<br>C_i \\<br>\\cdots \\[8pt]<br>\\cdots \\[8pt]<br>\\cdots<br>\\end{bmatrix}<br>$$</p>\n<p>一般情况下，计算得到$$C_i=1D_1\\oplus 3D_2\\oplus 0D_3\\oplus 2D_4\\oplus 1D_5\\oplus 0D_6\\oplus 3D_7\\oplus 7D_8$$</p>\n<p>该函数则先计算0和1对应的块，即$D_1,D_3,D_5,D_6$。$D_3,D_6$对应的矩阵元素为0，所以可以忽略($\\alpha \\oplus 0=\\alpha$)，即先得到$D_1\\oplus D_5$。接下来再利用$\\text{galois_w_region_multiply}$计算剩余的非$1$的点积，然后将二者异或即得到$C_i$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_bitmatrix_dotprod</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix_row,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"keyword\">int</span> *src_ids, <span class=\"keyword\">int</span> dest_id,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>含义同上一函数，方法为直接计算。从这里也可看出，$GF(2)$上的点积计算比$GF(2^w)$方便得多。</p>\n<h3 id=\"3-2-6-矩阵转置操作函数\"><a href=\"#3-2-6-矩阵转置操作函数\" class=\"headerlink\" title=\"3.2.6 矩阵转置操作函数\"></a>3.2.6 矩阵转置操作函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invert_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> *inv, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>利用初等变换法求$mat$的逆矩阵，将结果放入$inv$中。大小为$rows\\times rows$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invert_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> *inv, <span class=\"keyword\">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>利用初等变换法求$mat$的逆矩阵，将结果放入$inv$中。大小为$rows\\times rows$。此时的$w=1$，因此也可以用$jerasure_invert_matrix$求逆，但是该函数的时间复杂度为$O(n^2)$，用上一函数令$w=1$的时间复杂度为$O(n^3)$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invertible_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>判断$mat$是否可逆，不会求逆。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invertible_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>同上，判断$mat$是否可逆，不会求逆。</p>\n<h3 id=\"3-2-7-一些基本的矩阵操作函数\"><a href=\"#3-2-7-一些基本的矩阵操作函数\" class=\"headerlink\" title=\"3.2.7 一些基本的矩阵操作函数\"></a>3.2.7 一些基本的矩阵操作函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>输出$matrix$，根据$w$的大小确定列间距。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>输出$matrix$，每$w$个字符后插入一个空格，每$w$行后插入一个空白行。</p>\n<p>例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *m, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fw;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">30</span>];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> w2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (w == <span class=\"number\">32</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fw = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        w2 = (<span class=\"number\">1</span> &lt;&lt; w);</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(s, <span class=\"string\">&quot;%u&quot;</span>, w2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">        fw = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*u&quot;</span>, fw, m[i * cols + j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *m, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; i % w == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j != <span class=\"number\">0</span> &amp;&amp; j % w == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, m[i * cols + j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mat[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, </span><br><span class=\"line\">    \t\t\t <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bitmat[<span class=\"number\">6</span>*<span class=\"number\">15</span>] = &#123;   <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                           <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                           <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                           </span><br><span class=\"line\">                           <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                           <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                           <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    jerasure_print_matrix(mat, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    jerasure_print_bitmatrix(bitmat, <span class=\"number\">2</span>*<span class=\"number\">3</span>, <span class=\"number\">5</span>*<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    system(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为：<br><img src=\"https://img-blog.csdnimg.cn/20201117145029289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"输出结果\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">jerasure_matrix_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> *m1, <span class=\"keyword\">int</span> *m2, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> c1, <span class=\"keyword\">int</span> r2, <span class=\"keyword\">int</span> c2, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>计算矩阵乘法。$m_1$为$r_1\\times c_1$，$m_2$为$r_2\\times c_2$，计算$m_1\\times m_2$，显然$c_1=r_2$。</p>\n<h3 id=\"3-2-8-监测函数\"><a href=\"#3-2-8-监测函数\" class=\"headerlink\" title=\"3.2.8 监测函数\"></a>3.2.8 监测函数</h3><p>为评估编解码性能，JErasure库提供了一个监测函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_get_stats</span><span class=\"params\">(<span class=\"keyword\">double</span> *fill_in)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>fill_in</code>是含有$3$个<code>double</code>类型的向量，分别评价三个指标，其含义分别为：</p>\n<ol>\n<li><p>使用`galois_region_xor()进行了XOR运算的字节数；</p>\n</li>\n<li><p>使用<code>galois_w08_region_multiply()</code>, <code>galois_w16_region_multiply()</code> or <code>galois_w32_region_multiply()</code>来乘以常数的字节数，即$\\text{region}$的长度；</p>\n</li>\n<li><p>使用$\\text{memcpy()}$复制的字节数。</p>\n</li>\n</ol>\n<p>  调用该函数之后，上述三个指标将会被清空。具体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_get_stats</span><span class=\"params\">(<span class=\"keyword\">double</span> *fill_in)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  fill_in[<span class=\"number\">0</span>] = jerasure_total_xor_bytes;</span><br><span class=\"line\">  fill_in[<span class=\"number\">1</span>] = jerasure_total_gf_bytes;</span><br><span class=\"line\">  fill_in[<span class=\"number\">2</span>] = jerasure_total_memcpy_bytes;</span><br><span class=\"line\">  jerasure_total_xor_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  jerasure_total_gf_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  jerasure_total_memcpy_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["JErasure"],"tags":["galois field","Reed-Solomon Code","JErasure"]}]