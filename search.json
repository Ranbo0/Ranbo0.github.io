[{"title":"仙剑奇侠传五代码分析（一） -- 恢复/辅助类物品","url":"/2022/01/08/PAL5/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"物品回血回蓝\">物品回血回蓝</h1>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.ChangeHP(arg1, arg2, id, val) <span class=\"comment\">-- 回血</span></span><br><span class=\"line\">player.ChangeMP(arg1, arg2, id, val) <span class=\"comment\">-- 回蓝</span></span><br><span class=\"line\"><span class=\"comment\">-- arg1: 恢复类型；1: 按比例恢复 0: 按数值恢复</span></span><br><span class=\"line\"><span class=\"comment\">-- arg2: 恢复范围；1: 全体恢复   0: 单体恢复</span></span><br><span class=\"line\"><span class=\"comment\">-- val: 恢复量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- WARNING: 不要设置arg1/arg2为01以外的其他值，否则可能会造成未定义行为</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例1：</span></span><br><span class=\"line\">player.ChangeHP(<span class=\"number\">0</span>, <span class=\"number\">0</span>, id, <span class=\"number\">300</span>) <span class=\"comment\">-- 单体回复300点血</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例2：</span></span><br><span class=\"line\">player.ChangeMP(<span class=\"number\">0</span>, <span class=\"number\">1</span>, id, <span class=\"number\">20</span>)  <span class=\"comment\">-- 全体回复20点蓝</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例3：</span></span><br><span class=\"line\">player.ChangeHP(<span class=\"number\">1</span>, <span class=\"number\">1</span>, id, <span class=\"number\">-25</span>) <span class=\"comment\">-- 全体受到生命上限20%的伤害</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- WARINING: 在伤害型物品中，最好不要对敌人产生减蓝的操作</span></span><br><span class=\"line\"><span class=\"comment\">-- 因为PAL5/PAL5前传不像PAL4一样敌人有蓝，要对敌人产生减蓝可能产生未定义行为</span></span><br><span class=\"line\"><span class=\"comment\">-- 在修改代码时，务必考虑清楚该代码产生的行为是否可以使游戏保持一致性</span></span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<h1 id=\"物品移除状态\">物品移除状态</h1>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.RemoveStat(<span class=\"built_in\">arg</span>, id, stat) <span class=\"comment\">-- 移除状态</span></span><br><span class=\"line\"><span class=\"comment\">-- arg: 恢复范围；1: 全体恢复   0: 单体恢复</span></span><br><span class=\"line\"><span class=\"comment\">-- stat: 状态</span></span><br><span class=\"line\">    <span class=\"comment\">-- 0. 冻结; 1. 中毒; 2. 混乱; 3. 脱力; 4. 沉默;</span></span><br><span class=\"line\">    <span class=\"comment\">-- 5. 昏睡; 6. 异变; 7. 麻痹; 8. 消极; 9. 污浊。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- WARNING: 不要设置stat为0-9以外的其他值，否则可能会造成未定义行为</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例1：</span></span><br><span class=\"line\">player.RemoveStat(<span class=\"number\">0</span>, id, <span class=\"number\">0</span>) <span class=\"comment\">-- 单体解除冻结状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例2：</span></span><br><span class=\"line\">player.RemoveStat(<span class=\"number\">1</span>, id, <span class=\"number\">3</span>) <span class=\"comment\">-- 全体解除脱力状态</span></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"复活\">复活</h1>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.Relive(id) <span class=\"comment\">-- 复活</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- WARNING: 使用player的Relive方法时必须恢复一定的血量，否则会造成未知错误</span></span><br><span class=\"line\"><span class=\"comment\">-- 本人没有试过会出现什么错误，但是复活后保持0血量肯定是未定义（非法）状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例1：</span></span><br><span class=\"line\"><span class=\"comment\">-- 选定角色复活，并保持300点血量</span></span><br><span class=\"line\">player.Relive(id)</span><br><span class=\"line\">player.ChangeHP(<span class=\"number\">0</span>, <span class=\"number\">0</span>, id, <span class=\"number\">300</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例2：</span></span><br><span class=\"line\"><span class=\"comment\">-- 选定角色复活，并恢复所有角色所有生命值</span></span><br><span class=\"line\">player.Relive(id)</span><br><span class=\"line\">player.ChangeHP(<span class=\"number\">1</span>, <span class=\"number\">1</span>, id, <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"回气\">回气</h1>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.ChangeDP(<span class=\"built_in\">arg</span>, id, val) <span class=\"comment\">-- 回气</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- arg: 恢复范围；1: 全体恢复   0: 单体恢复</span></span><br><span class=\"line\"><span class=\"comment\">-- val: 恢复量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例1：</span></span><br><span class=\"line\">player.ChangeDP(<span class=\"number\">0</span>, id, <span class=\"number\">20</span>) <span class=\"comment\">-- 单体恢复20点气</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例2：</span></span><br><span class=\"line\">player.ChangeDP(<span class=\"number\">0</span>, id, <span class=\"number\">-100</span>) <span class=\"comment\">-- 单体气清空</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- WARINING: 在伤害型物品中，最好不要对敌人产生减气的操作</span></span><br><span class=\"line\"><span class=\"comment\">-- 因为PAL5/PAL5前传不像PAL4一样敌人有气，要对敌人产生减蓝可能产生未定义行为</span></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"永久增加属性\">永久增加属性</h1>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.AddProperty(id, prop, val) <span class=\"comment\">-- 增加指定属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- prop: 增加的属性种类</span></span><br><span class=\"line\">    <span class=\"comment\">-- 1. 力; 2. 体; 3. 速; 4. 术; 5. 运</span></span><br><span class=\"line\"><span class=\"comment\">-- val: 增量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例1:</span></span><br><span class=\"line\">player.AddProperty(id, <span class=\"number\">1</span>, <span class=\"number\">1</span>) <span class=\"comment\">-- 增加1点力</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例2:</span></span><br><span class=\"line\">player.AddProperty(id, <span class=\"number\">1</span>, <span class=\"number\">-5</span>) <span class=\"comment\">-- 减少5点力</span></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"添加状态\">添加状态</h1>\r\n<h2 id=\"添加基础状态\">添加基础状态</h2>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.AddStat(<span class=\"built_in\">arg</span>, id, pro, stat, turns) <span class=\"comment\">-- 添加状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- arg: 使用范围；1: 全体   0: 单体</span></span><br><span class=\"line\"><span class=\"comment\">-- pro: 添加状态成功率</span></span><br><span class=\"line\"><span class=\"comment\">-- stat: 状态</span></span><br><span class=\"line\">    <span class=\"comment\">-- 10: 强袭; 11: 坚盾; 12: 神行; 13: 法障</span></span><br><span class=\"line\"><span class=\"comment\">-- turns: 状态保持回合数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- WARNING: 不要设置turns/pro为负值，否则可能会造成未定义行为</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例1:</span></span><br><span class=\"line\">player.AddStat(<span class=\"number\">0</span>, id, <span class=\"number\">100</span>, <span class=\"number\">10</span>, <span class=\"number\">5</span>) <span class=\"comment\">-- 单体施加强袭状态5回合</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 例2：</span></span><br><span class=\"line\">player.AddStat(<span class=\"number\">0</span>, id, <span class=\"number\">50</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span>) <span class=\"comment\">-- 单体施加强袭状态1回合，50%失手</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"添加屏类状态\">添加屏类状态</h2>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.AddStat(<span class=\"built_in\">arg</span>, id, pro, stat, turns) <span class=\"comment\">-- 添加状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- arg: 使用范围；1: 全体   0: 单体</span></span><br><span class=\"line\"><span class=\"comment\">-- pro: 添加状态成功率</span></span><br><span class=\"line\"><span class=\"comment\">-- stat: 状态</span></span><br><span class=\"line\">    <span class=\"comment\">-- 14: 火屏; 15: 水屏; 16: 雷屏; 17: 土屏; 18: 风屏</span></span><br><span class=\"line\"><span class=\"comment\">-- turns: 状态保持回合数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 使用方法同上</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"添加高级状态\">添加高级状态</h2>\r\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">id = player.GetTargetPlayer() <span class=\"comment\">-- 获取角色id</span></span><br><span class=\"line\">player.AddStat(<span class=\"built_in\">arg</span>, id, pro, stat, turns) <span class=\"comment\">-- 添加状态</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- arg: 使用范围；1: 全体   0: 单体</span></span><br><span class=\"line\"><span class=\"comment\">-- pro: 添加状态成功率</span></span><br><span class=\"line\"><span class=\"comment\">-- stat: 状态</span></span><br><span class=\"line\">    <span class=\"comment\">-- 28: 隐形; 36: 武爆; 37: 魔免</span></span><br><span class=\"line\"><span class=\"comment\">-- turns: 状态保持回合数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 使用方法同上</span></span><br></pre></td></tr></table></figure>\r\n","categories":["PAL"],"tags":["PAL"]},{"title":"my first blog","url":"/2021/11/09/first%20blog/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>我的第一个博客。</p>\r\n<span id=\"more\"></span>\r\n<p>一些帮助链接：</p>\r\n<p><a href=\"https://hexo.io/\">Hexo</a></p>\r\n<p><a href=\"https://hexo.io/docs/\">documentation</a></p>\r\n<p><a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a></p>\r\n<p><a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a></p>\r\n<h2 id=\"quick-start\">Quick Start</h2>\r\n<h3 id=\"create-a-new-post\">Create a new post</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\r\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\r\n<h3 id=\"run-server\">Run server</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\r\n<h3 id=\"generate-static-files\">Generate static files</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\r\n<h3 id=\"deploy-to-remote-sites\">Deploy to remote sites</h3>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\r\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\r\n","tags":["test"]},{"title":"用github搭建博客巨无敌详细教程","url":"/2021/11/09/blog/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"一-环境准备\">一、 环境准备</h1>\r\n<h2 id=\"git\">1. <code>git</code></h2>\r\n<p><span class=\"math inline\">\\(\\text{link:}\\)</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://git-scm.com/</span><br></pre></td></tr></table></figure>\r\n<span id=\"more\"></span>\r\n<h2 id=\"node\">2. <code>node</code></h2>\r\n<p><span class=\"math inline\">\\(\\text{link: }\\)</span></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://nodejs.org/en/download/</span><br></pre></td></tr></table></figure>\r\n<p>安装完成后输入 <code>node -v</code></p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>输出版本号就安装完成了。</p>\r\n<h2 id=\"hexo\">3. <code>hexo</code></h2>\r\n<p><code>npm install hexo -g</code></p>\r\n<p>安装完成后输入 <code>hexo -v</code></p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>输出 <code>hexo</code> 以及 <code>hexo</code> 的部分依赖的版本号即安装完成。</p>\r\n<p>安装 <code>hexo</code> 依赖：</p>\r\n<p><code>npm install --save hexo-deployer-git</code></p>\r\n<h1 id=\"二-配置-ssh-key-可选\">二、 配置 <code>ssh-key</code> （可选）</h1>\r\n<h2 id=\"配置-ssh\">1. 配置 <code>ssh</code></h2>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &lt;your-email-address&gt;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"添加-ssh-key\">2. 添加 <code>ssh-key</code></h2>\r\n<p>在 <code>github</code> 主页，在左侧的 <code>SSH and GPG keys</code> 中，新建 <code>SSH-key</code>，自定义一个标题，将 <code>id_rsa.pub</code> 复制的内容粘贴到 <code>key</code> 中即可。</p>\r\n<figure>\r\n<img src=\"3.png\" alt=\"pic3\" /><figcaption aria-hidden=\"true\">pic3</figcaption>\r\n</figure>\r\n<h2 id=\"配置账号和密码\">3. 配置账号和密码</h2>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &lt;your-user-name&gt;</span><br><span class=\"line\">$ git config --global user.email &lt;your-email-address&gt;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"三-搭建博客\">三、 搭建博客</h1>\r\n<h2 id=\"在-github-新建仓库\">1. 在 <code>github</code> 新建仓库</h2>\r\n<p><img src=\"4.png\" /></p>\r\n<p>仓库名称格式： <code>用户名.github.io</code></p>\r\n<p>例如我的用户名是 <code>Ranbo0</code>，那么我的仓库名就要设置成 <code>Ranbo0.github.io</code></p>\r\n<p><img src=\"5.png\" /></p>\r\n<p>因为我已经创建过了，所以这里显示已存在。</p>\r\n<h2 id=\"修改配置文件\">2. 修改配置文件</h2>\r\n<p>在 <code>hexo</code> 根目录下有个配置文件 <code>_config.yml</code> ，修改其中的 <code>deploy</code> ，表示每次更新博客时上传的仓库。</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: git@github.com:Ranbo0/Ranbo0.github.io.git</span><br><span class=\"line\">  branch: main</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"6.png\" /></p>\r\n<p>其中 <code>repository</code> 和 <code>branch</code> 根据自己的仓库设置。</p>\r\n<h2 id=\"hexo-基本命令\">3. <code>hexo</code> 基本命令</h2>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;&lt;blog-name&gt;&quot;</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">&quot;&lt;page-name&gt;&quot;</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo g <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class=\"line\">hexo s <span class=\"comment\">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#部署到GitHub</span></span><br><span class=\"line\">hexo d <span class=\"comment\">#部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo h  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo v  <span class=\"comment\">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"创建第一篇博客\">4. 创建第一篇博客</h2>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">&quot;my first blog&quot;</span></span><br></pre></td></tr></table></figure>\r\n<p><img src=\"8.png\" /></p>\r\n<p>然后会在 <code>source/_posts</code> 下创建一个名为 <code>my-first-blog.md</code> 的文件，修改该文件后即可将文件上传到自己的博客上了。</p>\r\n<p><img src=\"9.png\" /></p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo g</span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"7.png\" /></p>\r\n<p>其中的 <code>http://localhost:4000</code> 是预览页面，可以在达到自己的效果之后再提交到 <code>github</code> 上。</p>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\r\n<p>每次提交之前可以先 <code>hexo clean</code> ，然后再执行 <code>hexo g</code> 和 <code>hexo d</code> 。</p>\r\n<p><img src=\"10.png\" /></p>\r\n<p>如图所示，即成功上传。</p>\r\n<ul>\r\n<li><p>当执行 <code>hexo d</code> 时出现 <code>ERROR Deployer not found: git</code> 的报错信息时，再次安装<code>hexo-deployer-git</code>：</p>\r\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<p>以上即是搭建自己的博客的教程。</p>\r\n<hr />\r\n<p>下面介绍如何渲染自己的博客。首先要安装 <code>nexT</code> ：</p>\r\n<h1 id=\"四-安装主题\">四、 安装主题</h1>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"五-启用主题及相关配置\">五、 启用主题及相关配置</h1>\r\n<h2 id=\"启用主题\">1. 启用主题</h2>\r\n<p>打开 <code>hexo</code> 的 <code>_config.yml</code> 文件，找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>\r\n<p><img src=\"11.png\" /></p>\r\n<h2 id=\"验证主题安装成功\">2. 验证主题安装成功</h2>\r\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\r\n<p>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>\r\n<p>若此时的界面与未安装 <code>next</code> 时的界面相同，或者全部是纯文本则表示主题安装失败，需要重新安装。</p>\r\n<h2 id=\"主题设置\">3. 主题设置</h2>\r\n<p><code>Scheme</code> 是 <code>NexT</code>提供的一种特性，借助于 <code>Scheme</code>，<code>NexT</code>为你提供多种不同的外观。同时，几乎所有的配置都可以 在 <code>Scheme</code>之间共用。目前 <code>NexT</code>支持三种 <code>Scheme</code>，分别是：</p>\r\n<ul>\r\n<li><code>Muse</code>- 默认 <code>Scheme</code>，这是 <code>NexT</code>最初的版本，黑白主调，大量留白</li>\r\n<li><code>Mist</code> - <code>Muse</code>的紧凑版本，整洁有序的单栏外观</li>\r\n<li><code>Pisces</code> - 双栏 <code>Scheme</code></li>\r\n<li><code>Gemini</code> - 分栏</li>\r\n</ul>\r\n<p>要修改主题，打开 <code>nexT</code> 中的 <code>_config.yml</code> 文件，找到 <code>Schemes</code> ，将想要设置的主题取消注释即可。</p>\r\n<p><img src=\"12.png\" /></p>\r\n<h2 id=\"设置语言\">4. 设置语言</h2>\r\n<p>打开 <code>hexo</code> 的 <code>_config.yml</code> 文件，找到 <code>language</code> 字段，修改为 <code>zh-CN</code> 即为简体中文， <code>zh-hk</code> 即为繁体中文， <code>en</code> 为英文等。</p>\r\n<h2 id=\"其他\">5. 其他</h2>\r\n<p>其他的设置可以根据<a href=\"http://theme-next.iissnan.com/getting-started.html\">开始使用 - NexT 使用文档 (iissnan.com)</a> 进行。</p>\r\n","tags":["教程"]},{"title":"JErasure库的相关介绍","url":"/2021/11/10/galois/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>JErasure库提供一般的RS码和CRS码两种编码方式，是基于C的纠删码的类库。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"一galois-field\">一、Galois Field</h1>\r\n<h2 id=\"一基本概念\">（一）基本概念</h2>\r\n<h3 id=\"域field\">1.1.1 域（field）</h3>\r\n<p>域代表一组元素和元素间的四则运算的集合。其中，域内元素的四则运算必须满足封闭性，也就是说域内元素进行四则运算后得到的结果仍为域内元素。</p>\r\n<h3 id=\"有限域finite-field\">1.1.2 有限域（finite field）</h3>\r\n<p>有限域即为仅含有有限个元素的域。有限域又称作伽罗华域(Galois Field)。记为<span class=\"math inline\">\\(GF\\)</span>。例如，<span class=\"math inline\">\\(GF(7)\\)</span>的元素为0~6.</p>\r\n<p>有限域中必须含有加法单位元和乘法单位元。加法单位元即域中的<strong>零元</strong>，即存在元素<span class=\"math inline\">\\(e\\)</span>，使得域中任一元素<span class=\"math inline\">\\(a\\)</span>，有<span class=\"math inline\">\\(e+a = a\\)</span>。乘法单位元即域中的<strong>幺元</strong>，即存在元素e，使得域中任一元素<span class=\"math inline\">\\(a\\)</span>，有<span class=\"math inline\">\\(e*a = a\\)</span>。<span class=\"math inline\">\\(GF(p)\\)</span>的加法单位元和乘法单位元分别为0和1.</p>\r\n<p>此外，有限域中的每个元素还应有对应的逆元。乘法逆元与我们常见的倒数类似。即存在元素b，使得<span class=\"math inline\">\\(b*a = e\\)</span>，则<span class=\"math inline\">\\(b\\)</span>为<span class=\"math inline\">\\(a\\)</span>的乘法逆元。其中<span class=\"math inline\">\\(e\\)</span>为乘法单位元。加法逆元与我们常见的相反数类似。即存在元素<span class=\"math inline\">\\(b\\)</span>，使得<span class=\"math inline\">\\(b+a = e\\)</span>，则<span class=\"math inline\">\\(b\\)</span>为<span class=\"math inline\">\\(a\\)</span>的加法逆元。其中<span class=\"math inline\">\\(e\\)</span>为加法单位元。</p>\r\n<p>有限域中的减法和除法即为加法和乘法的逆过程。<span class=\"math inline\">\\(GF(p)\\)</span>的加法和乘法与实数域内的加法和乘法相似，只不过最后要模<span class=\"math inline\">\\(p\\)</span>。即<span class=\"math inline\">\\(GF(a+b) = (a+b) \\mod p， GF(a×b) = (a×b) \\mod p\\)</span>。</p>\r\n<p>一般而言，<span class=\"math inline\">\\(p\\)</span>应为质数，因为如果<span class=\"math inline\">\\(p\\)</span>非质数，则可能有一些元素找不到乘法逆元。例如<span class=\"math inline\">\\(GF(9)\\)</span>中，元素3找不到<span class=\"math inline\">\\(GF(9)\\)</span>中的一个元素<span class=\"math inline\">\\(a\\)</span>使<span class=\"math inline\">\\(3\\times a \\mod p = 1\\)</span>，即3没有乘法逆元。</p>\r\n<h2 id=\"二gf2w\">（二）<span class=\"math inline\">\\(GF(2^w)\\)</span></h2>\r\n<h3 id=\"gf2w\">1.2.1 <span class=\"math inline\">\\(GF(2^w)\\)</span></h3>\r\n<p><span class=\"math inline\">\\(GF(2^w)\\)</span>上的加法运算和乘法运算不使用一般的加法和乘法，而是使用多项式的计算。</p>\r\n<h3 id=\"多项式计算\">1.2.2 多项式计算</h3>\r\n<p><span class=\"math inline\">\\(GF(2^w)\\)</span>上的多项式计算中，多项式的系数为1或0，即只能取<span class=\"math inline\">\\(GF(2)\\)</span>上的元素；当进行加法运算时，合并同类项时，不是一般的系数相加，而是进行异或计算，且加法和减法的操作一致。例如： <span class=\"math display\">\\[\r\n(x^3+x^2)+(x^4+x^2)=x^4+x^3\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(GF(2^w)\\)</span>上的多项式的最高次不超过<span class=\"math inline\">\\(w\\)</span>。例如，在<span class=\"math inline\">\\(GF(2^3)\\)</span>中，<span class=\"math inline\">\\(f_1(x)=x^2+1\\)</span>为<span class=\"math inline\">\\(GF(2^3)\\)</span>的多项式，<span class=\"math inline\">\\(f_2(x)=x^3+x^2+1\\)</span>则不是<span class=\"math inline\">\\(GF(2^3)\\)</span>的多项式。</p>\r\n<p>但是，多项式的加法计算后的结果一定仍为域中多项式，而对于多项式乘法，若直接按一般的多项式乘法计算的计算结果则可能不再是域中的多项式。与<span class=\"math inline\">\\(GF(p)\\)</span>类似，需要找到一个多项式对其取模，使之仍然为域中多项式。因此，提出本原多项式的概念。</p>\r\n<h3 id=\"本原多项式质多项式textprimitive-polynomial\">1.2.3 本原多项式/质多项式(<span class=\"math inline\">\\(\\text{primitive polynomial}\\)</span>)</h3>\r\n<p>质多项式与质数的概念类似，质多项式即为不能表示成除幺元对应的多项式与该多项式以外的其他多项式的乘积，即<strong>不能再进行因式分解的多项式</strong>。例如，在<span class=\"math inline\">\\(GF(2^4)\\)</span>中，<span class=\"math inline\">\\(f(x) = x^4 + 1\\)</span>不是<span class=\"math inline\">\\(GF(2^4)\\)</span>上的质多项式，因为<span class=\"math inline\">\\(f(x) = (x^2 + 1) × (x^2 + 1)\\)</span>。<span class=\"math inline\">\\(g(x) = x^4 + x + 1\\)</span>是<span class=\"math inline\">\\(GF(2^4)\\)</span>上的质多项式，因为它不可再分解。</p>\r\n<p>以<span class=\"math inline\">\\(GF(2^3)\\)</span>为例，指数小于3的多项式一共有8个，分别是<span class=\"math inline\">\\(0，1，x，x+1，x^2，x^2+1，x^2+x，x^2+x+1\\)</span>，一共有8个多项式。其对应的系数分别可以表示为<code>000</code>，<code>001</code>，<code>010</code>，<code>011</code>，<code>100</code>，<code>101</code>，<code>110</code>，<code>111</code>，若用十进制表示，则正好为<code>0</code>，<code>1</code>，<code>2</code>，<code>3</code>，<code>4</code>，<code>5</code>，<code>6</code>，<code>7</code>。这说明0~7与8个多项式之间有着必然的映射关系，每个多项式会对应一个值。对于<span class=\"math inline\">\\(GF(2^3)\\)</span>，取素多项式<span class=\"math inline\">\\(f(x) = x^3+x+1\\)</span>，则<span class=\"math inline\">\\(x+1\\)</span>的乘法逆元为<span class=\"math inline\">\\(x^2+x\\)</span>，因为<span class=\"math inline\">\\(((x+1) × (x^2+x) mod (x^3+x+1) = 1)\\)</span>，也就是说即使<span class=\"math inline\">\\(\\mod 8\\)</span>不能构成一个有限域，但是由质多项式仍然可以为域中每个元素找到一个乘法逆元。 此时，多项式的乘法即可得到解决。例如，在<span class=\"math inline\">\\(GF(2^3)\\)</span>内： <span class=\"math display\">\\[\r\nx\\times (x^2+1)=x\\times (x^2+1)\\mod (x^3+x+1)=(x^3+x)\\mod (x^3+x+1)=1\r\n\\]</span></p>\r\n<p>对于多项式除法，根据<span class=\"math display\">\\[r(x) = q(x)t(x) + s(x)\\]</span>，其中<span class=\"math inline\">\\(r(x),q(x),t(x),s(x)\\)</span>均为<span class=\"math inline\">\\(GF(2^w)\\)</span>上的多项式，<span class=\"math inline\">\\(q(x)\\)</span>表示<span class=\"math inline\">\\(GF(2^w)\\)</span>上的质多项式。易知<span class=\"math inline\">\\(r(x) \\mod q(x) = s(x)\\)</span>，且显然有<span class=\"math inline\">\\(dim\\ s(x) &lt; dim\\ q(x)\\)</span>。（<span class=\"math inline\">\\(dim\\ f(x)\\)</span>表示的是<span class=\"math inline\">\\(f(x)\\)</span>的最高次的次数）。</p>\r\n<p>根据上述理论，即可根据质多项式来得到<span class=\"math inline\">\\(GF(2^w)\\)</span>的所有元素。<span class=\"math inline\">\\(GF(2^w)\\)</span>中元素的生成过程如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 给定一个初始集合&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, x&#125;;</span><br><span class=\"line\"><span class=\"number\">2.</span> 将这个集合的最后一个元素乘以x。如果得到的结果的度(dim) ≥ w，则将结果 <span class=\"function\">mod <span class=\"title\">q</span><span class=\"params\">(x)</span>，将结果加入集合中</span>;</span><br><span class=\"line\"><span class=\"number\">3.</span> 重复<span class=\"number\">2</span>，直到集合中有<span class=\"number\">2</span>^w个元素。此时最后的一个元素乘以x再 <span class=\"function\">mod <span class=\"title\">q</span><span class=\"params\">(x)</span>的值必定为1.</span></span><br></pre></td></tr></table></figure>\r\n<p>举个栗子： <span class=\"math inline\">\\(w = 2\\)</span>时，<span class=\"math inline\">\\(q(x) = x^2 + x + 1\\)</span>，初始集合为<span class=\"math inline\">\\(\\{0, 1, x\\}\\)</span>，</p>\r\n<p>最后一个元素为<span class=\"math inline\">\\(x\\)</span>，乘以<span class=\"math inline\">\\(x\\)</span>后为<span class=\"math inline\">\\(x^2\\)</span>，<span class=\"math inline\">\\(dim\\ (x^2) = 2\\)</span>，因此要对<span class=\"math inline\">\\(q(x)\\)</span>取模，得<span class=\"math inline\">\\((x^2) \\mod (x^2 + x + 1) = x + 1\\)</span>；此时集合更新为<span class=\"math inline\">\\(\\{0, 1, x, x+1\\}\\)</span>；</p>\r\n<p>再将最后一个元素乘以<span class=\"math inline\">\\(x\\)</span>，为<span class=\"math inline\">\\(x^2 + x\\)</span>,仍需要对<span class=\"math inline\">\\(q(x)\\)</span>取模，得<span class=\"math inline\">\\((x^2 + x) mod (x^2 + x + 1) = 1\\)</span>,结束上述过程。即<span class=\"math inline\">\\(GF(2^2) = \\{0, 1, x, x+1\\}\\)</span>。</p>\r\n<p>也就是说，只需要找到对应<span class=\"math inline\">\\(GF(2^w)\\)</span>上的本原多项式<span class=\"math inline\">\\(q(x)\\)</span>即可通过<span class=\"math inline\">\\(x\\)</span>代换得到<span class=\"math inline\">\\(GF(2^w)\\)</span>，即： <span class=\"math display\">\\[\r\nGF(2^w) = GF(2)[x]/q(x)\r\n\\]</span></p>\r\n<p>常用的本原多项式有：</p>\r\n<pre><code>w = 4:   x^4 + x + 1\r\nw = 8:   x^8 + x^4 + x^3 + x^2 + 1\r\nw = 16:  x^16 + x^12 + x^3 + x + 1\r\nw = 32:  x^32 + x^22 + x^2 + x + 1\r\nw = 64:  x^64 + x^4 + x^3 + x + 1</code></pre>\r\n<p>例如，<span class=\"math inline\">\\(GF(2^4)\\)</span>的元素生成：(<span class=\"math inline\">\\(P(x) = x^4 + x + 1\\)</span>) <img src=\"https://img-blog.csdnimg.cn/20201113002057855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"GF(2^4)的元素生成过程\" /></p>\r\n<p>由上述计算结果，可以构建以下两个表（正表和反表)：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\"><strong>i</strong></th>\r\n<th style=\"text-align: center;\"><strong>0</strong></th>\r\n<th style=\"text-align: center;\"><strong>1</strong></th>\r\n<th style=\"text-align: center;\"><strong>2</strong></th>\r\n<th style=\"text-align: center;\"><strong>3</strong></th>\r\n<th style=\"text-align: center;\"><strong>4</strong></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">gflog[i]</td>\r\n<td style=\"text-align: center;\">-</td>\r\n<td style=\"text-align: center;\">0</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">2</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">gfilog[i]</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">3</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\"><strong>5</strong></td>\r\n<td style=\"text-align: center;\"><strong>6</strong></td>\r\n<td style=\"text-align: center;\"><strong>7</strong></td>\r\n<td style=\"text-align: center;\"><strong>8</strong></td>\r\n<td style=\"text-align: center;\"><strong>9</strong></td>\r\n<td style=\"text-align: center;\"><strong>10</strong></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">3</td>\r\n<td style=\"text-align: center;\">14</td>\r\n<td style=\"text-align: center;\">9</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">6</td>\r\n<td style=\"text-align: center;\">12</td>\r\n<td style=\"text-align: center;\">11</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">19</td>\r\n<td style=\"text-align: center;\">7</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\"><strong>11</strong></td>\r\n<td style=\"text-align: center;\"><strong>12</strong></td>\r\n<td style=\"text-align: center;\"><strong>13</strong></td>\r\n<td style=\"text-align: center;\"><strong>14</strong></td>\r\n<td style=\"text-align: center;\"><strong>15</strong></td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">7</td>\r\n<td style=\"text-align: center;\">6</td>\r\n<td style=\"text-align: center;\">13</td>\r\n<td style=\"text-align: center;\">11</td>\r\n<td style=\"text-align: center;\">12</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">14</td>\r\n<td style=\"text-align: center;\">15</td>\r\n<td style=\"text-align: center;\">13</td>\r\n<td style=\"text-align: center;\">9</td>\r\n<td style=\"text-align: center;\">-</td>\r\n<td style=\"text-align: center;\"></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>其中，<code>gflog[i]</code>表（反表）是将二进制映射成多项式，例如将5映射成多项式，即<span class=\"math inline\">\\(gflog[5] = 8\\)</span>,即<span class=\"math inline\">\\(x^8 = 5\\)</span>；<code>gfilog[i]</code>表（正表）是将多项式映射成二进制(值),例如将5(即<span class=\"math inline\">\\(x^5\\)</span>)映射成值，即<span class=\"math inline\">\\(gfilog[5] = 6\\)</span>,即<span class=\"math inline\">\\(x^5 = 6\\)</span>.</p>\r\n<p>对于乘法和除法，可以由如下方式进行： <span class=\"math display\">\\[\r\nx^a\\times x^b=x^{a+b};\\\\\r\nx^a/x^b=x^{a-b}.\r\n\\]</span></p>\r\n<p>因此，我们在计算可以<span class=\"math inline\">\\(a×b\\)</span>时，可以先得到<span class=\"math inline\">\\(a = x^m, b = x^n\\)</span>; 则<span class=\"math inline\">\\(a\\times b = x^{m + n}, a/b = x^{m - n}\\)</span>.</p>\r\n<p>即：先将<span class=\"math inline\">\\(a，b\\)</span>查找反表（gflog[i]）得到<span class=\"math inline\">\\(m，n\\)</span>；计算<span class=\"math inline\">\\(m + n\\)</span>或者<span class=\"math inline\">\\(m - n\\)</span>，然后基于结果查找正表（gfilog[i]）得到乘法和除法的结果。需要注意的是，在计算<span class=\"math inline\">\\(m + n\\)</span>和<span class=\"math inline\">\\(m - n\\)</span>时，若结果大于等于15或小于0，则需要对15(<span class=\"math inline\">\\(2^w - 1\\)</span>)取模。因为0是单独存在的，在<span class=\"math inline\">\\(GF(2^w)\\)</span>中没有哪个元素的任意次方等于0.</p>\r\n<p>再举个栗子：</p>\r\n<p>7 × 9 = gfilog[gflog[7] + gflog[9]] = gfilog[10 + 14] = gfilog[9] = 10</p>\r\n<p>(<span class=\"math inline\">\\(7 × 9 = x^{10} × x^{14} = x^{10 + 14} = x^{24 \\mod 15} = x^9 = 10\\)</span>)</p>\r\n<p>13 / 11 = gfilog[gflog[13] - gflog[11]] = gfilog[13 - 7] = gfilog[6] = 12</p>\r\n<p>(<span class=\"math inline\">\\(13 / 11 = x^{13} / x^7 = x^{13-7} = x^6 = 12\\)</span>)</p>\r\n<p>因此，构造正反表之后，可以大大简化乘法和除法的计算，可以直接通过加法和查表得到结果，而不需要再进行繁琐的取模等运算。</p>\r\n<h1 id=\"二crs码\">二、CRS码</h1>\r\n<h2 id=\"一rs码简介\">（一）RS码简介</h2>\r\n<p>介绍CRS码之前先要弄明白RS码是什么。RS码就是Reed-Solomon码，是一种<strong>MDS码</strong>。编码时将k个数据块通过一定方式编码成m个校验块，我一般把它写成<strong>RS(k, m)</strong>，<strong>最多可以容忍m个数据块失效</strong>。解码时通过m个幸存块来恢复所有的数据块。那么RS码是通过什么方式来编码和解码的呢？ RS码通过构造生成矩阵来编码数据块。前k×k为单位阵，后m×k为生成矩阵。编码过程即为生成矩阵与数据块进行矩阵的乘法，即得到k个数据块和m个校验块。 <img src=\"https://img-blog.csdnimg.cn/20201113104722746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Encoding\" /> 当有<strong>不多于m个块失效</strong>时，为了恢复数据块，则取出k个幸存块对应的生成矩阵的行构成一个矩阵，对该矩阵的逆与对应的幸存块相乘即可恢复出数据块。 例如，数据块<span class=\"math inline\">\\(D_2，D_3\\)</span>和校验块<span class=\"math inline\">\\(P_1\\)</span>丢失，取出k个幸存块对应的生成矩阵的行，例如取出<span class=\"math inline\">\\(D_1，D_4， ...，D_k，P_2，P_3\\)</span>，一共<span class=\"math inline\">\\(k\\)</span>个数据块，有： <img src=\"https://img-blog.csdnimg.cn/2020111310581920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Decoding_1\" /> 再将左边的子矩阵的逆乘到右侧，即有： <img src=\"https://img-blog.csdnimg.cn/20201113110151141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Decoding_2\" /> 此时，所有的数据块就被恢复出来了。再要恢复校验块，很简单，再进行一次编码操作即可得到所有正确的校验块了。 然后问题来了，RS码的编解码步骤已经清楚了，现在就只有一个待解决的问题了，那就是得找到一个合适的生成矩阵，使得该生成矩阵的任意k行都线性无关，也就是说任意k行组成的矩阵的行列式不为0，此时即可保证任意k行组成的子矩阵必定可逆。因此，在RS码中，我们一般采用 <strong>范德蒙德矩阵（Vandermonde Matrix）</strong> 作为生成矩阵，此时该矩阵的任意k行组成的子矩阵一定可逆。 用范德蒙德矩阵进行编码的时间复杂度为<code>O(mk)</code>，解码的时间复杂度为<code>O(k^3)</code>。 在利用范德蒙德矩阵编码的时候，我们可以采用对数/反对数表的方法将乘法运算转换成加法运算，并且在迦罗华域中，加法运算转换成了XOR运算。 显然，这种方法要比直接复制副本存储的空间开销小得多，但是解码时花费的时间有点多了。所以，基于Reed-Solomon码，又有另一种纠删码被提出 -- <strong>Cauchy Reed-Solomon Code</strong>。</p>\r\n<h2 id=\"二crs-code简介\">（二）CRS Code简介</h2>\r\n<h3 id=\"cauchy-matrix\">2.2.1 Cauchy Matrix</h3>\r\n<p>Cauchy矩阵是由两个交集为空的集合构成的矩阵。具体为：</p>\r\n<p>令C = [c<sub>ij</sub>]<sub>m<span class=\"math inline\">\\(\\times\\)</span>n</sub>，有集合X = {<span class=\"math inline\">\\(x_1, x_2, \\cdots, x_m\\)</span>}，Y = {<span class=\"math inline\">\\(y_1, y_2, \\cdots, y_n\\)</span>}，且X∩Y = ∅。矩阵C中的元素<span class=\"math inline\">\\(c_{ij}\\)</span>满足 <span class=\"math display\">\\[\r\nc_{ij} = \\frac{1}{x_i + y_j}\r\n\\]</span> 则矩阵C为Cauchy矩阵。</p>\r\n<p>Cauchy矩阵有一个很重要的性质，即Cauchy矩阵的任意一个子方阵必定可逆。且求逆的时间复杂度为O(<span class=\"math inline\">\\(n^2\\)</span>)，<span class=\"math inline\">\\(n\\)</span>为子方阵的维数。 例如，对于<span class=\"math inline\">\\(X = \\{1, 2\\}\\)</span>，<span class=\"math inline\">\\(Y = \\{0, 3, 4, 5, 6\\}\\)</span>，其编解码过程如下： <img src=\"https://img-blog.csdnimg.cn/20201113112600996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"Cauchy matrix‘s encoding and decoding\" /> 从编解码过程来看，柯西编解码最大的运算量是乘法和加法运算。柯西编解码为了降低乘法复杂度，采用了有限域上的元素都可以使用二进制矩阵表示的原理，将乘法运算和加法运算转换成了迦罗华域“<strong>与运算</strong>”和“<strong>XOR逻辑运算</strong>”，提高了编解码效率。</p>\r\n<p>从数学的角度来看，在迦罗华有限域中，任何一个GF(<span class=\"math inline\">\\(2^w\\)</span>)域上的元素都可以映射到GF(2)二进制域，并且采用一个二进制矩阵的方式表示GF（<span class=\"math inline\">\\(2^w\\)</span>）中的元素。例如，GF（<span class=\"math inline\">\\(2^3\\)</span>）域中的元素可以表示成GF（2）域中的二进制矩阵： <img src=\"https://img-blog.csdnimg.cn/20201113113320150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"GF(2^3) to GF(2)\" /> 其中，<span class=\"math inline\">\\(M(e)\\)</span>的第<span class=\"math inline\">\\(i\\)</span>列为<span class=\"math inline\">\\(V(e * 2^{i-1})\\)</span>.其中<span class=\"math inline\">\\(e*2^{i-1}\\)</span>为<span class=\"math inline\">\\(GF(2^3)\\)</span>上的乘法。通过以上规则，可以得到： <span class=\"math display\">\\[\r\nM(e_1) * V(e_2) = V(e_1e_2)，\\\\ M(e_1) * M(e_2) = M(e_1e_2) \\\\ \r\n\\]</span> . 举个栗子：</p>\r\n<p><img src=\"https://img-blog.csdnimg.cn/20201113113607895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"GF(2^3)的乘法转化为GF(2)的乘法\" /> 根据上述理论，将Cauchy matrix的每个元素(<span class=\"math inline\">\\(e\\)</span>)全部替换成<span class=\"math inline\">\\(M(e)\\)</span>，以此替换即可将计算从<span class=\"math inline\">\\(GF(2^w)\\)</span>上的计算变为<span class=\"math inline\">\\(GF(2)\\)</span>的计算(位运算)。为了可以使两矩阵能进行乘法计算，将每个数据块并没有划分为<span class=\"math inline\">\\(2^w\\)</span>大小，而是划分为<span class=\"math inline\">\\(w\\)</span>，即将每个数据块分为<span class=\"math inline\">\\(w\\)</span>块。例如，对前文所述的Cauchy matrix和<span class=\"math inline\">\\(GF(2^3)\\)</span>，有： <img src=\"https://img-blog.csdnimg.cn/2020111311384323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"convert Cauchy matrix to bitmatrix\" /> ### 2.2.2 相关证明 上述结论可以证明。证明过程如下：</p>\r\n<p>令<span class=\"math inline\">\\(P(x)\\)</span>为<span class=\"math inline\">\\(GF(2)[x]\\)</span>中的<span class=\"math inline\">\\(L\\)</span>次本原多项式。由前文介绍的Galois Field中的理论，可以得知<span class=\"math inline\">\\(GF(2^L)\\)</span>中的元素可以由<span class=\"math inline\">\\(f(x) = \\sum_{i = 0}^{L-1}f_ix^i\\)</span>表出，其中<span class=\"math inline\">\\(f_i\\in GF(2)\\)</span>。记列向量<span class=\"math display\">\\[(f_1, f_2, \\cdots, f_{L-1})\\]</span>为<span class=\"math inline\">\\(f(x)\\)</span>的系数向量（coefficient vector）。</p>\r\n<p>对属于<span class=\"math inline\">\\(GF(2^L)\\)</span>的任意多项式<span class=\"math inline\">\\(f(x)\\)</span>，令<span class=\"math inline\">\\(\\tau(f)\\)</span>为系数向量的矩阵，其中<span class=\"math inline\">\\(\\tau(f)\\)</span>的第<span class=\"math inline\">\\(i\\)</span>列为<span class=\"math display\">\\[x^{i-1}f(x) \\pmod {P(x)}\\]</span>的系数向量。 根据以上定义，有以下引理：</p>\r\n<p>（1）<span class=\"math inline\">\\(\\tau(0)\\)</span>是零矩阵；</p>\r\n<p>（2）<span class=\"math inline\">\\(\\tau(1)\\)</span>是单位矩阵；</p>\r\n<p>（3）<span class=\"math inline\">\\(\\tau\\)</span>是单射；</p>\r\n<p>（4）<span class=\"math inline\">\\(\\tau(f) + \\tau(g) = \\tau(f+g)\\)</span>；<span class=\"math inline\">\\(f\\)</span>和<span class=\"math inline\">\\(g\\)</span>是<span class=\"math inline\">\\(GF(2^L)\\)</span>的多项式；</p>\r\n<p>（5）<span class=\"math inline\">\\(\\tau(f)\\tau(g) = \\tau(fg)\\)</span>；<span class=\"math inline\">\\(f\\)</span>和<span class=\"math inline\">\\(g\\)</span>是<span class=\"math inline\">\\(GF(2^L)\\)</span>的多项式</p>\r\n<p>其中(1)到(3)很容易证明，这里只证明(4)和(5): <span class=\"math display\">\\[\r\nx^i(f+g) = x^if + x^ig \\pmod {P(x)}\r\n\\]</span> 其中<span class=\"math inline\">\\(x^i(f + g)\\)</span>表示以<span class=\"math inline\">\\(\\tau(f + g)\\)</span>的第<span class=\"math inline\">\\(i\\)</span>列为系数的多项式，<span class=\"math inline\">\\(x^if\\)</span>和<span class=\"math inline\">\\(x^ig\\)</span>表示以<span class=\"math inline\">\\(\\tau(f)\\)</span>和<span class=\"math inline\">\\(\\tau(g)\\)</span>的第<span class=\"math inline\">\\(i\\)</span>列为系数的多项式。显然，(4)得证。 令<span class=\"math inline\">\\(f^{(i)}\\)</span>表示<span class=\"math inline\">\\(\\tau(f)\\)</span>的第<span class=\"math inline\">\\(i\\)</span>列; 令<span class=\"math inline\">\\(\\{g_0^{(j)}, g_1^{(j)}, \\cdots, g_{L-1}^{(j)}\\}^T\\)</span>为<span class=\"math inline\">\\(\\tau(g)\\)</span>的第<span class=\"math inline\">\\(j\\)</span>列。则有： <span class=\"math display\">\\[\r\n\\sum_{i=0}^{L-1}g_i^{(j)}x^i = x^{j-1}g \\mod p(x)\r\n\\]</span> (其中<span class=\"math inline\">\\(p(x)\\)</span>为<span class=\"math inline\">\\(GF(2^L)\\)</span>上的质多项式，<span class=\"math inline\">\\(g = g_0^{(1)}+g_1^{(1)}x + g_2^{(1)}x^2 + \\cdots + g_{L-1}^{(1)}x^{L-1}\\)</span>)</p>\r\n<p>因<span class=\"math inline\">\\(\\tau(f)\\tau(g)\\)</span>的第<span class=\"math inline\">\\(j\\)</span>列为： <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\nf^{(1)} &amp; f^{(2)} &amp; \\cdots &amp; f^{(L)}\r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\n\\cdots &amp; g_0^{(j)} &amp; \\cdots \\\\\r\n\\cdots &amp; g_1^{(j)} &amp; \\cdots \\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots \\\\\r\n\\cdots &amp; g_{L-1}^{(j)} &amp; \\cdots \\\\\r\n\\end{bmatrix}\r\n\\]</span> <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n &amp;= g_0^{(j)}f^{(1)}+g_1^{(j)}f^{(2)}+ \\cdots +g_{L-1}^{(j)}f^{(L)}\\\\\r\n&amp;= \\sum_{i=0}^{L-1}g_i^{(j)}f^{(i+1)}\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p>这就是下面这个的多项式的系数向量： <span class=\"math display\">\\[\r\n\\sum_{i=0}^{L-1}g_i^{(j)}(x^if) = f\\sum_{i=0}^{L-1}g_i^{(j)}x^i = x^{j-1}fg \\mod p(x)\r\n\\]</span> 即：<span class=\"math inline\">\\(\\tau(f)\\tau(g)\\)</span>的第j列与<span class=\"math inline\">\\(\\tau(fg)\\)</span>的第j列相同</p>\r\n<p>即：<span class=\"math inline\">\\(\\tau(f)\\tau(g)=\\tau(fg)\\)</span></p>\r\n<p>也就是说，将<span class=\"math inline\">\\(GF(2^w)\\)</span>映射成<span class=\"math inline\">\\(\\tau(GF(2^w))\\)</span>后，仍然有加法和乘法的不变性，即: <span class=\"math display\">\\[\r\nM(e_1) * M(e_2) = M(e_1e_2)\r\n\\]</span></p>\r\n<p>若将<span class=\"math inline\">\\(M(e_2)\\)</span>的第一列提取出来，即为： <span class=\"math display\">\\[\r\nM(e_1) * V(e_2) = V(e_1e_2)\r\n\\]</span></p>\r\n<p>至此，前面的理论已完全证毕。</p>\r\n<p>现在再来证明Cauchy matrix的求逆过程可以在<span class=\"math inline\">\\(O(n^2)\\)</span>的时间复杂度内完成。</p>\r\n<p>对于Cauchy矩阵的任意一个子方阵<span class=\"math inline\">\\(C = [c_{ij}]_{n\\times n}\\)</span>: <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\frac{1}{x_1+y_1} &amp; \\frac{1}{x_1+y_2} &amp; \\cdots &amp; \\frac{1}{x_1+y_n}  \\\\[10pt]\r\n\\frac{1}{x_2+y_1} &amp; \\frac{1}{x_2+y_2} &amp; \\cdots &amp; \\frac{1}{x_2+y_n} \\\\[10pt]\r\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\[10pt]\r\n\\frac{1}{x_n+y_1} &amp; \\frac{1}{x_n+y_2} &amp; \\cdots &amp; \\frac{1}{x_n+y_n} \r\n\\end{bmatrix}\r\n\\]</span> 其行列式 <span class=\"math display\">\\[\r\n\\det C = \\frac{\\prod_{i&lt;j}(x_i-x_j)\\prod_{i&lt;j}(y_i-y_j)}{\\prod_{i,j = 1}^n(x_i+y_j)}\r\n\\]</span> 令<span class=\"math inline\">\\(C^{-1} = [d_{ij}]\\)</span>，则有</p>\r\n<p><span class=\"math display\">\\[\r\nd_{ij} = (-1)^{i+j}\\frac{\\det C_{ji}}{\\det C_j}\r\n\\]</span> 其中<span class=\"math inline\">\\(c_{ji}\\)</span>表示删除了第<span class=\"math inline\">\\(j\\)</span>行和第<span class=\"math inline\">\\(i\\)</span>列的矩阵<span class=\"math inline\">\\(C\\)</span>。令 <span class=\"math display\">\\[\r\n\\begin{align}\r\na_k &amp;= \\prod_{i&lt;k}(x_i-x_k)\\prod_{k&lt;j}(x_k-x_j)\\\\\r\nb_k &amp;= \\prod_{i&lt;k}(y_i-y_k)\\prod_{k&lt;j}(y_j-y_k)\\\\\r\nc_k &amp;= \\prod_{i=1}^n(x_k+y_i)\\\\\r\nf_k &amp;= \\prod_{i=1}^n(y_k+x_i)\r\n\\end{align}\r\n\\]</span> 因此，有：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align}\r\n\\det C &amp;= \\frac{\\prod_{k=1}^na_kb_k}{\\prod_{k=1}^ne_kf_k}\\\\\r\n\\det C_{ji} &amp;= \\frac{\\det C e_jf_i}{a_jb_i(x_j+y_i)}\r\n\\end{align}\r\n\\]</span> 因此：</p>\r\n<p><span class=\"math display\">\\[\r\nd_{ij} = (-1)^{i+j}\\frac{e_jf_i}{a_jb_i(x_j+y_i)}\r\n\\]</span> 所以<span class=\"math inline\">\\(4n\\)</span>个未知量<span class=\"math inline\">\\(a_k, b_k, c_k, f_k\\)</span>可以在<span class=\"math inline\">\\(O(n^2)\\)</span>的时间复杂度内被解出，而<span class=\"math inline\">\\(d_{ij}\\)</span>则可由上述公式在<span class=\"math inline\">\\(O(1)\\)</span>的时间复杂度得到，因此，Cauchy矩阵的求逆过程可以在<span class=\"math inline\">\\(O(n^2)\\)</span>的时间复杂度内得到。</p>\r\n<h1 id=\"三jerasure库源码分析\">三、JErasure库源码分析</h1>\r\n<h2 id=\"一galois.cgalois.h\">（一）Galois.c/Galois.h</h2>\r\n<p>这两个文件中定义的函数比较简单。首先：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> prim_poly[<span class=\"number\">33</span>]; <span class=\"comment\">//对应的w的各个质多项式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> mult_type[<span class=\"number\">33</span>]; <span class=\"comment\">//对于不同的w采用不同的乘法计算</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> nw[<span class=\"number\">33</span>];\t\t  <span class=\"comment\">//存放的是2^w的值，nwm1是2^w-1的值，即GF(2^w)的最大值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_log_tables[<span class=\"number\">33</span>];  <span class=\"comment\">//各个w(1~30)的反表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_ilog_tables[<span class=\"number\">33</span>]; <span class=\"comment\">//各个w(1~30)的正表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_mult_tables[<span class=\"number\">33</span>]; <span class=\"comment\">//各个w(1~30)的乘法表</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> *galois_div_tables[<span class=\"number\">33</span>];  <span class=\"comment\">//各个w(1~30)的除法表</span></span><br></pre></td></tr></table></figure>\r\n<p>以上是Galois.c中定义的一系列表，这些表将会在之后进行构造。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_create_log_tables</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//创建w的正反表，且将正表复制了两份，以便构建乘法表和除法表，然后将正表的初始位置(galois_log_tables[w][0]置为第二个副本的起始位置)，返回0表示构建成功，返回1表示失败</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_logtable_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查正反表计算x*y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_logtable_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查正反表计算x/y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_create_mult_tables</span><span class=\"params\">(<span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//构建大小为nw[w] * nw[w]的乘法表和除法表</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_ilog</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//求value对应的二进制的值，即x^value对应的数值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_log</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//求value对应的多项式，即value对应的x^i的i值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_shift_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//移位乘法，不需要任何表即可实现，但需要w次乘2，w次判断。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//对于x*y，先计算出y*2, y*2^2, y*2^3, ..., y*2^w-1的值，然后将x化为二进制，对x的第i位为1的，取出y*2^i进行异或得到结果。</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_multtable_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查乘法表求x*y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_invert_binary_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> *inv, <span class=\"keyword\">int</span> rows)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//用初等变换法计算二进制矩阵mat的逆矩阵，mat的每一个元素表示一行，应为w，即w = row，若不可逆则停止运行程序</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_inverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//若w = 23~32，用移位，否则直接用galois_single_multiply计算1/x</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_shift_inverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//以移位的方式求y的倒数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//先由y得到mat2[w] = &#123;y, y*2, y*2^2, ..., y*2^w-1&#125;，通过galois_invert_binary_matrix函数得到mat2[w]的逆矩阵inv，inv[0]即为1/y的值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_single_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//计算x*y，对于不同的w采用不同的乘法策略：</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/********************************</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 1~9: 构造乘法表，查乘法表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 10~22: 构建正反表，查正反表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 23~31: 用移位乘法</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 32: 用裂乘</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> ********************************/</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_single_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//计算a/b，对于不同的w采用不同的除法策略：</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/********************************</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 1~9: 构造除法表，查除法表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 10~22: 构建正反表，查正反表</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> * w = 23~32: 先得到b的倒数(galois_inverse(b, w))，再用galois_single_multiply函数计算(分为w = 23~31和w = 32的两种策略)</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"function\"> ********************************/</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_shift_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//利用galois_shift_inverse函数得到b的倒数，再利用移位乘法得到a/b的值</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_multtable_divide</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//查除法表得x/y</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_create_split_w8_tables</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//创建裂乘表</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">galois_split_w8_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//裂乘</span></span></span><br></pre></td></tr></table></figure>\r\n<p>其中，裂乘的思路如下： 对于<span class=\"math inline\">\\(x\\times y\\)</span>，以<span class=\"math inline\">\\(GF(2^{32})\\)</span>为例，<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>均为域内元素，则<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>可表示成： <span class=\"math display\">\\[\r\nx = x_0+2^8\\times x_1+2^{2\\times 8}\\times x_2+2^{3\\times 8}\\times x_3 \\\\\r\ny = y_0+2^8\\times y_1+2^{2\\times 8}\\times y_2+2^{3\\times 8}\\times y_3\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(x_i\\)</span>和<span class=\"math inline\">\\(y_i\\)</span>均为unit8_t型数据，<span class=\"math inline\">\\(i \\in \\{0, 1, 2, 3\\}\\)</span>. 则： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\nx\\times y &amp;= ( x_0+2^8\\times x_1+2^{2\\times 8}\\times x_2+2^{3\\times 8}\\times x_3)\\times (y_0+2^8\\times y_1+2^{2\\times 8}\\times y_2+2^{3\\times 8}\\times y_3)\\\\\r\n&amp;=x_0y_0\\\\\r\n&amp;+\\ 2^8\\times (x_0y_1+x_1y_0)\\\\\r\n&amp;+\\ 2^{2 \\times 8}\\times (x_0y_2+x_1y_1+x_2y_0)\\\\\r\n&amp;+\\ 2^{3 \\times 8}\\times (x_0y_3+x_1y_2+x_2y_1+x_3y_0)\\\\\r\n&amp;+\\ 2^{4 \\times 8}\\times (x_1y_3+x_2y_2+x_3y_1)\\\\\r\n&amp;+\\ 2^{5 \\times 8}\\times (x_2y_3+x_3y_2)\\\\\r\n&amp;+\\ 2^{6 \\times 8}\\times (x_3y_3)\r\n\\end{aligned}\r\n\\]</span> 因此，设<span class=\"math inline\">\\(\\alpha\\)</span>为unit32_t类型数中只有低<span class=\"math inline\">\\(8\\)</span>位的任意数字，那么根据上述<span class=\"math inline\">\\(x\\times y\\)</span>的拆分结果可以归结为 <span class=\"math display\">\\[\r\n\\alpha \\times \\alpha, \\alpha \\times (\\alpha &lt;&lt; 8), \\alpha \\times (\\alpha&lt;&lt;16),\\alpha \\times (\\alpha&lt;&lt;24),\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n (\\alpha &lt;&lt; 8)\\times (\\alpha&lt;&lt;24),(\\alpha &lt;&lt; 16)\\times (\\alpha&lt;&lt;24),(\\alpha &lt;&lt; 24)\\times (\\alpha&lt;&lt;24)\r\n\\]</span></p>\r\n<p>一共7种运算。每一种运算可以用一个乘法表表示，每个乘法表大小为<span class=\"math inline\">\\(2^8\\times 2^8\\times 4\\ Bytes\\)</span>.</p>\r\n<p>以上为Galois field上的一些基本运算。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_region_xor</span><span class=\"params\">(<span class=\"keyword\">char</span> *r1,         <span class=\"comment\">/* Region 1 */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"keyword\">char</span> *r2,         <span class=\"comment\">/* Region 2 */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"keyword\">char</span> *r3,         <span class=\"comment\">/* Sum region (r3 = r1 ^ r2) */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                       <span class=\"keyword\">int</span> nbytes)</span></span>;      <span class=\"comment\">/* Number of bytes in region */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_w08_region_multiply</span><span class=\"params\">(<span class=\"keyword\">char</span> *region,       <span class=\"comment\">/* Region to multiply */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> multby,       <span class=\"comment\">/* Number to multiply by */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> nbytes,       <span class=\"comment\">/* Number of bytes in region */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">char</span> *r2,         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">/* If r2 != NULL, products go here.Otherwise region is overwritten */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> add)</span></span>;         </span><br><span class=\"line\"><span class=\"comment\">/* If (r2 != NULL &amp;&amp; add) the produce is XOR&#x27;d with r2 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_w16_region_multiply</span><span class=\"params\">(<span class=\"keyword\">char</span> *region,       <span class=\"comment\">/* Region to multiply */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> multby,       <span class=\"comment\">/* Number to multiply by */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> nbytes,       <span class=\"comment\">/* Number of bytes in region */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">char</span> *r2,         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">/* If r2 != NULL, products go here. Otherwise region is overwritten */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> add)</span></span>;         </span><br><span class=\"line\"><span class=\"comment\">/* If (r2 != NULL &amp;&amp; add) the produce is XOR&#x27;d with r2 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">galois_w32_region_multiply</span><span class=\"params\">(<span class=\"keyword\">char</span> *region,       <span class=\"comment\">/* Region to multiply */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> multby,       <span class=\"comment\">/* Number to multiply by */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">int</span> nbytes,       <span class=\"comment\">/* Number of bytes in region */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                <span class=\"keyword\">char</span> *r2,         </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"><span class=\"comment\">/* If r2 != NULL, products go here. Otherwise region is overwritten */</span></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">int</span> add)</span></span>;         </span><br><span class=\"line\"><span class=\"comment\">/* If (r2 != NULL &amp;&amp; add) the produce is XOR&#x27;d with r2 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上述三个函数均为将region中各个元素乘以multby</span></span><br><span class=\"line\"><span class=\"comment\">// 1. r2 == NULL,则将结果写入region，结束</span></span><br><span class=\"line\"><span class=\"comment\">// 2. r2 != NULL 且 add is false,则将结果写入r2</span></span><br><span class=\"line\"><span class=\"comment\">// 3. r2 != NULL 且 add is true,将结果与r2异或再写入r2</span></span><br></pre></td></tr></table></figure>\r\n<p>以上四个函数为域内乘法，第一个表示将两个等大的数组<span class=\"math inline\">\\(r_1\\)</span>和<span class=\"math inline\">\\(r_2\\)</span>按元素进行异或，将结果置入<span class=\"math inline\">\\(r_3\\)</span>中。后面3个函数主要用来求点积，具体的实现步骤已经标注在上面的注释中了，点积的概念将在之后介绍到。</p>\r\n<h2 id=\"二jerasure.cjerasure.h\">（二）JErasure.c/JErasure.h</h2>\r\n<h3 id=\"函数的参数介绍\">3.2.1 函数的参数介绍</h3>\r\n<p>在分析函数功能之前，先弄明白这两个文件中定义的函数的参数。</p>\r\n<p><span class=\"math inline\">\\(K\\)</span> = 数据块数量</p>\r\n<p><span class=\"math inline\">\\(M\\)</span> = 校验块(coding devices)数量</p>\r\n<p><span class=\"math inline\">\\(W\\)</span> = 字长</p>\r\n<p><span class=\"math inline\">\\(data\\_ptrs[][]\\)</span> = 包含<span class=\"math inline\">\\(k\\)</span>个指向大小为size bytes的数据的指针的数组，即数据块指针，<span class=\"math inline\">\\(size\\)</span>必须是sizeof(long)的整数倍</p>\r\n<p><span class=\"math inline\">\\(coding\\_ptrs[][]\\)</span> = 指向编码数据（大小为字节）的m个指针数组，即校验块指针</p>\r\n<p><span class=\"math inline\">\\(packetsize\\)</span> = 使用bitmatrix编码的编码块(coding block)大小</p>\r\n<p><span class=\"math inline\">\\(Matrix[]\\)</span> = 包含<span class=\"math inline\">\\(k\\times m\\)</span>个整数(integer)的数组，即编码矩阵，其中<span class=\"math inline\">\\(i\\)</span>行<span class=\"math inline\">\\(j\\)</span>列元素为<span class=\"math inline\">\\(matrix[i\\times k+j]\\)</span></p>\r\n<p><span class=\"math inline\">\\(Bitmatrix[]\\)</span> = 包含<span class=\"math inline\">\\(kw \\times mw\\)</span>个整数(integer)的数组，其中<span class=\"math inline\">\\(i\\)</span>行<span class=\"math inline\">\\(j\\)</span>列元素为<span class=\"math inline\">\\(bitmatrix[i\\times kw+j]\\)</span></p>\r\n<p><span class=\"math inline\">\\(Erasures[]\\)</span> = 已删除的设备(devices)(块)的<span class=\"math inline\">\\(id\\)</span>的数组，用于记录哪些块丢失 <span class=\"math inline\">\\(id∈[0, k+m-1]\\)</span> <span class=\"math inline\">\\(id∈[0, k-1]：数据块id\\)</span> <span class=\"math inline\">\\(id∈[k, k+m-1]：编码块(校验块)id\\)</span> <span class=\"math inline\">\\(例如：erasures[0] = 0;\\)</span> //第<span class=\"math inline\">\\(0\\)</span>个块丢失 <span class=\"math inline\">\\(erasures[1] = 3;\\)</span> //第<span class=\"math inline\">\\(3\\)</span>个块丢失 <span class=\"math inline\">\\(erasures[2] = -1;\\)</span> //结束标志</p>\r\n<p><span class=\"math inline\">\\(Operation[op][]\\)</span> = 包含5个整数的数组(五元组) <span class=\"math inline\">\\(4 : 进行操作 - 0表示复制，1表示异或\\)</span> <span class=\"math inline\">\\(0 : 源设备(device)[0,k+m-1](operation[op][0] = -1表示结束)\\)</span> <span class=\"math inline\">\\(1 : 源数据包(packet)[0,w-1]\\)</span> <span class=\"math inline\">\\(2 : 目标设备[0,k+m-1]\\)</span> <span class=\"math inline\">\\(3 : 目标数据包[0,w-1]\\)</span></p>\r\n<p>我这里只介绍各个接口的实现和作用，各位最好还是对照源码来理解各个参数的含义。</p>\r\n<h3 id=\"位矩阵编解码的时空优化方案\">3.2.2 位矩阵编解码的时空优化方案</h3>\r\n<p>因为位矩阵的大小变成了<span class=\"math inline\">\\(kw\\times mw\\)</span>，比之前的矩阵大了<span class=\"math inline\">\\(w^2-1\\)</span>倍，空间利用率极低。而且在编码校验块的时候，中间可能会有大量的XOR操作是重复的，例如 <span class=\"math display\">\\[\r\nP_{1,1}=D_{1,1} \\otimes D_{1,2};\\\\\r\n    P_{1,2}=D_{1,1} \\otimes D_{1,2} \\otimes D_{2,2};\\\\\r\n    P_{2,1}=D_{1,1} \\otimes D_{2,2} \\otimes D_{3,1}\r\n\\]</span> 因此，可以由<span class=\"math display\">\\[P_{1,2}=P_{1,1} \\otimes D_{2,2} \\\\P_{2,1}=P_{1,2}\\otimes D_{2,2}\\otimes D_{3,1}\\]</span>来减少XOR次数，一般而言，<span class=\"math inline\">\\(kw\\)</span>和<span class=\"math inline\">\\(mw\\)</span>较大，所以以这种方式来减少XOR次数是可以减少编解码时间的。</p>\r\n<p>刚刚那个栗子只减少了1次XOR操作，看起来8太行。现在来举个好一点的栗子： <img src=\"https://img-blog.csdnimg.cn/20201113153306999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" /> 由上面的图上所示，按照位矩阵的XOR操作得到校验块，可以得到： <img src=\"https://img-blog.csdnimg.cn/20201113153439304.png#pic_center\" /> 但是很显然，中间有大量的XOR操作可以重复利用。如果将其重复的结果进行分类，则可以有以下结果： <img src=\"https://img-blog.csdnimg.cn/20201113153729783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" /> 很显然，这次是大大的减少所需的XOR操作。</p>\r\n<p>以这种思路，JErasure库给出了两种方式来分别实现提高空间利用率和进一步减少XOR的操作数：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> **<span class=\"title\">jerasure_dumb_bitmatrix_to_schedule</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//将bitmatrix转换为一系列操作。简单粗暴。</span></span><br><span class=\"line\"><span class=\"comment\">//返回一个operations[][]数组，具体实现方式为：</span></span><br><span class=\"line\"><span class=\"comment\">//若bitmatrix[index] == 1，则计算得到当前bitmatrix位置对应的数据块位置，如果在该行是第一个bitmatrix[index] == 1，则置operation为0(copy)，否则为1(XOR)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> **<span class=\"title\">jerasure_smart_bitmatrix_to_schedule</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 采用与上一函数类似的方法，不过使用之前的结果来计算新的点积。</span></span><br></pre></td></tr></table></figure>\r\n<p>这两个函数都是将位矩阵(bitmatrix)转化为了调度(schedule)，既减少空间开销，也减少了XOR次数。 先来分析第一个函数：(dumb) 其实就是在模拟位矩阵与数据包的矩阵乘法过程。例如： <img src=\"https://img-blog.csdnimg.cn/2020111315183021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" /> 例如: <span class=\"math display\">\\[C_{11}=D_{11} \\otimes D_{21} \\otimes D_{22} \\otimes D_{33}\\otimes D_{41} \\otimes D_{42} \\otimes D_{43} \\otimes D_{52}\\]</span> <span class=\"math inline\">\\(jerasure\\_dumb\\_bitmatrix\\_to\\_schedule\\)</span>即模拟<span class=\"math inline\">\\(D_{11}, \\cdots, D_{52}\\)</span>的操作，且每个operation元素对应了一个源块和目标块的位置，以及要进行的操作。 例如，<span class=\"math inline\">\\(D_{11}\\)</span>对应的源块即为<span class=\"math inline\">\\((1,1)\\)</span>，目标块<span class=\"math inline\">\\(C_{11}\\)</span>即为<span class=\"math inline\">\\((1,1)\\)</span>，因为<span class=\"math inline\">\\(D_{11}\\)</span>在第一个位置上，所以操作为复制(copy)，即为<span class=\"math inline\">\\((0)\\)</span>，因此，<span class=\"math inline\">\\(D_{11}\\)</span>对应的五元组为<span class=\"math inline\">\\((1,1,1,1,0)\\)</span>. 再例如，<span class=\"math inline\">\\(D_{21}\\)</span>对应的源块即为<span class=\"math inline\">\\((2,1)\\)</span>，目标块<span class=\"math inline\">\\(C_{11}\\)</span>即为<span class=\"math inline\">\\((1,1)\\)</span>，因为<span class=\"math inline\">\\(D_{21}\\)</span>不在第一个位置上，也就是说之前已经开始计算异或结果了，所以此时操作为异或(XOR)，即为<span class=\"math inline\">\\((1)\\)</span>，代表XOR <span class=\"math inline\">\\(D_{21}\\)</span>，因此，<span class=\"math inline\">\\(D_{11}\\)</span>对应的五元组为<span class=\"math inline\">\\((2,1,1,1,1)\\)</span>.</p>\r\n<p>现在来分析第二个函数：(smart) 前面那个函数只是开胃菜，这个函数才是对位运算的大大优化。基本思路与上一函数类似，但是这个会使用之前计算过的XOR结果(点积)来编码新的校验块。 下面是这种中间结果复用的实现方式：</p>\r\n<p>先定义一些记号，以便后续说明： <span class=\"math inline\">\\(\\text{from[]含有r个元素，初始置-1}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\text{diff[]含r个元素}，\\text{diff[i]表示Mi中1的数量}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\text{flink[]和 blink[]用于定位top，top用于找当前待计算的校验块}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\text{bestdiff记录当前最小的diff[i]的值}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\text{bestrow记录当前bestdiff对应的diff[i]的 i的值}\\)</span></p>\r\n<p>实现步骤： 假定<span class=\"math inline\">\\(M\\)</span>为<span class=\"math inline\">\\(bitmatrix\\)</span>，<span class=\"math inline\">\\(V\\)</span>为输入的数据块，<span class=\"math inline\">\\(U\\)</span>为生成的校验块，<span class=\"math inline\">\\(notdone\\)</span>代表待生成的校验块<span class=\"math inline\">\\(id\\)</span>的集合，初始为<span class=\"math inline\">\\(0\\)</span> ~ <span class=\"math inline\">\\(mw-1\\)</span>，则步骤如下:</p>\r\n<pre><code>1. 选择未计算的校验块的packet且diff[i]最小的 i，即找到i∈notdone且diff[i]最小\r\n2. 若from[i] = -1, 则令operation[op]的元素为M[i, j] = 1的所有对应的数据块;\r\n   若from[i] ≠ -1, 则令operation[op]的第一个元素为校验块from[i]，之后的元素为第from[i]行与i行相异的bitmatrix中的元素对应的数据块\r\n3. 从notdone中删除i\r\n4. 对于notdone中的任一元素j，计算第j行与第i行中相异的元素的数量c，令x = c + 1，若x &lt; diff[j]，则diff[j] = x，from[j] = i</code></pre>\r\n<p>也就是说，在某一次计算中，如果<span class=\"math inline\">\\(from[i] != -1\\)</span>，则说明第<span class=\"math inline\">\\(i\\)</span>个校验块的计算中用前面的计算过的结果来计算第i个校验块比直接进行矩阵乘法用到的XOR数要少，如果<span class=\"math inline\">\\(from[i] == -1\\)</span>，则说明用前面的结果计算该校验块不如直接计算来的快，就直接从<span class=\"math inline\">\\(bitmatrix\\)</span>中进行异或运算。</p>\r\n<p>效率分析： 例如，在解码过程中，要计算得到<span class=\"math inline\">\\(D_0\\)</span>和<span class=\"math inline\">\\(D_1\\)</span>，通过一般的矩阵乘法计算，一共需要124次XORs。但是，如果按照上述方案： 1. 找到含有最少的1的一行(记为第<span class=\"math inline\">\\(i\\)</span>行)，即计算<span class=\"math inline\">\\(D_{1,3}\\)</span>对应的一行，一共有8个1，因此共7次XORs。 2. 计算其他9行(记为第<span class=\"math inline\">\\(j\\)</span>行)与<span class=\"math inline\">\\(D_{1,3}\\)</span>对应的<span class=\"math inline\">\\(bitmatrix\\)</span>的行中相异元素的数量，如果第<span class=\"math inline\">\\(j\\)</span>行中1的数量小于刚才计算出的数量+1，说明由第<span class=\"math inline\">\\(j\\)</span>行计算块得到结果需要的XOR数量多于由第<span class=\"math inline\">\\(j\\)</span>行计算块得到结果需要的XOR数量，此时将<span class=\"math inline\">\\(from[j]\\)</span>置为<span class=\"math inline\">\\(i\\)</span>，即第<span class=\"math inline\">\\(j\\)</span>行的XOR数量由第<span class=\"math inline\">\\(i\\)</span>行的结果来得到比当前方法更快。 3. 重复之，直到计算得到了所有的块。 <img src=\"https://img-blog.csdnimg.cn/20201113154800579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" /> 根据上述理论分析，可以得出以下计算步骤： <img src=\"https://img-blog.csdnimg.cn/20201113155916771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" /> 此时一共需要46次XORs操作。相比之前的124次XORs，这种方法得到了大幅优化。</p>\r\n<h3 id=\"无返回值void的函数\">3.2.3 无返回值(void)的函数</h3>\r\n<p>接下来是几个无返回值的函数，比较简单，所以拿出来放在一块儿分析了。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_do_parity</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> *parity_ptr, <span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 由data_ptrs直接进行XOR操作生成校验块，结果放入parity_ptr中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_matrix_encode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 按常规方式编码，w必须是8，16，32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_bitmatrix_encode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 按常规方式对位矩阵编码，w ∈ [1, 32] and w ∈ N*</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_schedule_encode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> **schedule,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 使用jerasure_smart_bitmatrix_to_schedule()或者jerasure_dumb_bitmatrix_to_schedule()进行编码，具体方案由schedule[][]确定</span></span><br></pre></td></tr></table></figure>\r\n<p>没有什么难懂的地方，我根据自己的理解加了两句注释，大家看看代码也很容易就看懂了。</p>\r\n<h3 id=\"返回整数integer的函数\">3.2.4 返回整数(integer)的函数</h3>\r\n<p>这种返回整数的函数都是值返回<span class=\"math inline\">\\(0\\)</span>和<span class=\"math inline\">\\(-1\\)</span>的，返回<span class=\"math inline\">\\(0\\)</span>说明这个函数完整的进行了操作，返回成功的标志；返回<span class=\"math inline\">\\(-1\\)</span>说明参数有误，中途中断，返回失败的标志。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_matrix_decode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> row_k_ones, <span class=\"keyword\">int</span> *erasures,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p><span class=\"math inline\">\\(k\\)</span>表示数据块，<span class=\"math inline\">\\(m\\)</span>表示校验块，<span class=\"math inline\">\\(matrix\\)</span>表示生成矩阵，<span class=\"math inline\">\\(row\\_k\\_ones\\)</span>用于记录编码的第一行是否为全1，用于优化，<span class=\"math inline\">\\(data\\_ptrs\\)</span>表示指向数据块的指针，<span class=\"math inline\">\\(coding\\_ptrs\\)</span>表示指向校验块的指针，<span class=\"math inline\">\\(erasures\\)</span>记录哪些块失效，<span class=\"math inline\">\\(size\\)</span>表示块大小。 这个函数表示创建<span class=\"math inline\">\\(GF(2^w)\\)</span>上的解码矩阵进行解码，且最终会丢弃解码矩阵。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_bitmatrix_decode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">int</span> *bitmatrix, <span class=\"keyword\">int</span> row_k_ones, <span class=\"keyword\">int</span> *erasures,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>表示创建<span class=\"math inline\">\\(GF(2)\\)</span>上的矩阵（位矩阵）进行解码，参数同上。<span class=\"math inline\">\\(packetsize\\)</span>是使用位矩阵进行编解码时一个<span class=\"math inline\">\\(packet\\)</span>的大小。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_schedule_decode_lazy</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix, <span class=\"keyword\">int</span> *erasures,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize, <span class=\"keyword\">int</span> smart)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>若<span class=\"math inline\">\\(smart == 1\\)</span>，则采用<span class=\"math inline\">\\(jerasure\\_smart\\_bitmatrix\\_to\\_schedule()\\)</span>来创建调度（schedule），否则采用<span class=\"math inline\">\\(jerasure\\_smart\\_bitmatrix\\_to\\_schedule()\\)</span>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_make_decoding_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> *erased, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">int</span> *decoding_matrix, <span class=\"keyword\">int</span> *dm_ids)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>创建解码矩阵，但是不解码，解码矩阵存放在<span class=\"math inline\">\\(decoding\\_matrix\\)</span>中，<span class=\"math inline\">\\(dm\\_ids\\)</span>含有<span class=\"math inline\">\\(k\\)</span>个整数，即用这<span class=\"math inline\">\\(k\\)</span>个存活块来构建解码矩阵，最终生成的<span class=\"math inline\">\\(decoding\\_matrix\\)</span>含有<span class=\"math inline\">\\(k\\times k\\)</span>个整数。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_make_decoding_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> *erased, </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                                  <span class=\"keyword\">int</span> *decoding_matrix, <span class=\"keyword\">int</span> *dm_ids)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>同上，创建解码位矩阵，但是不解码，解码矩阵存放在<span class=\"math inline\">\\(decoding\\_matrix\\)</span>中，<span class=\"math inline\">\\(dm\\_ids\\)</span>含有<span class=\"math inline\">\\(kw\\)</span>个整数，即用这<span class=\"math inline\">\\(kw\\)</span>个存活块来构建解码矩阵，最终生成的<span class=\"math inline\">\\(decoding\\_matrix\\)</span>含有<span class=\"math inline\">\\(kw\\times kw\\)</span>个整数。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">jerasure_erasures_to_erased</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> *erasures)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>将<span class=\"math inline\">\\(erasures[]\\)</span>转换成<span class=\"math inline\">\\(erased[]\\)</span>返回，其中<span class=\"math inline\">\\(erased[]\\)</span>标识了哪些位置上的 <span class=\"math inline\">\\(packet\\)</span>不可用。例如<span class=\"math inline\">\\(erased[2] = 1\\)</span>说明第<span class=\"math inline\">\\(2\\)</span>个<span class=\"math inline\">\\(packet\\)</span>不可用（从第<span class=\"math inline\">\\(0\\)</span>个<span class=\"math inline\">\\(packet\\)</span>开始计数）。举个栗子： 若<span class=\"math display\">\\[erasures[] = \\{0,2,3\\}\\]</span>则<span class=\"math display\">\\[ erased[] = \\{1,0,1,1\\} \\]</span></p>\r\n<h3 id=\"求点积dot-product的函数\">3.2.5 求点积（dot product）的函数</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_matrix_dotprod</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *matrix_row,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">int</span> *src_ids, <span class=\"keyword\">int</span> dest_id,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                          <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>简单来说，就是将生成矩阵（编码矩阵/解码矩阵）的一行元素与数据块/幸存块相乘（求点积）。</p>\r\n<p>数据块/幸存块的id存放在<span class=\"math inline\">\\(src\\_ids\\)</span>中，例如： <img src=\"https://img-blog.csdnimg.cn/20201117112501820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"dot_product\" /> <span class=\"math inline\">\\(D_{1,1}\\)</span>的id为<span class=\"math inline\">\\(0\\)</span>，<span class=\"math inline\">\\(D_{4,3}\\)</span>的id为<span class=\"math inline\">\\(12\\)</span>，<span class=\"math inline\">\\(C_{1,1}\\)</span>的id为<span class=\"math inline\">\\(16\\)</span>等。</p>\r\n<p><font color=#FF0000>*<strong>注意：此处为了简单起见，给出的例子全部是以<span class=\"math inline\">\\(1\\)</span>开始计算id的，而一般情况下，应该从<span class=\"math inline\">\\(0\\)</span>开始。例如将上述<span class=\"math inline\">\\(D_{1\\to5}\\)</span>和<span class=\"math inline\">\\(C_{1\\to2}\\)</span>换成<span class=\"math inline\">\\(D_{0\\to4}\\)</span>和<span class=\"math inline\">\\(C_{0\\to1}\\)</span>，则<span class=\"math inline\">\\(D_{0,0}\\)</span>的id是<span class=\"math inline\">\\(0\\)</span>，<span class=\"math inline\">\\(D_{4,3}\\)</span>的id是<span class=\"math inline\">\\(11\\)</span>等。</strong></font></p>\r\n<p>编码/解码生成的块的id存放在<span class=\"math inline\">\\(dest\\_id\\)</span>中。若<span class=\"math inline\">\\(src\\_ids = null\\)</span>，则说明是在编码过程中，直接利用<span class=\"math inline\">\\(data\\_ptrs\\)</span>计算点积即可，若<span class=\"math inline\">\\(src\\_ids\\ne null\\)</span>，则说明是在解码过程中，则需要从<span class=\"math inline\">\\(data\\_ptrs\\)</span>和<span class=\"math inline\">\\(coding\\_ptrs\\)</span>中得到对应的数据块/幸存块再计算点积。</p>\r\n<p>该函数的对乘法计算进行了稍微的优化工作。因为点击计算需要<span class=\"math inline\">\\(GF(2^w)\\)</span>的乘法和加法，所以它会首先计算<span class=\"math inline\">\\(matrix\\)</span>中为<span class=\"math inline\">\\(0\\)</span>或<span class=\"math inline\">\\(1\\)</span>对应的块，然后再计算其他块，以简化计算的复杂度。例如： <span class=\"math display\">\\[\r\n\\begin{bmatrix}\r\n\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\\r\n\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\\r\n\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\\r\n1 &amp; 3 &amp; 0 &amp; 2 &amp; 1 &amp; 0 &amp; 3 &amp; 7 \\\\\r\n\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\\r\n\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\\r\n\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \r\n\\end{bmatrix}\r\n\\begin{bmatrix}\r\nD_1 \\\\[8pt]\r\nD_2 \\\\[8pt]\r\nD_3 \\\\[8pt]\r\nD_4 \\\\[8pt]\r\nD_5 \\\\[8pt]\r\nD_6 \\\\[8pt]\r\nD_7 \\\\[8pt]\r\nD_8\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\n\\cdots \\\\[8pt]\r\n\\cdots \\\\[8pt]\r\n\\cdots \\\\[8pt]\r\nC_i \\\\\r\n\\cdots \\\\[8pt]\r\n\\cdots \\\\[8pt]\r\n\\cdots\r\n\\end{bmatrix}\r\n\\]</span></p>\r\n<p>一般情况下，计算得到<span class=\"math display\">\\[C_i=1D_1\\oplus 3D_2\\oplus 0D_3\\oplus 2D_4\\oplus 1D_5\\oplus 0D_6\\oplus 3D_7\\oplus 7D_8\\]</span></p>\r\n<p>该函数则先计算0和1对应的块，即<span class=\"math inline\">\\(D_1,D_3,D_5,D_6\\)</span>。<span class=\"math inline\">\\(D_3,D_6\\)</span>对应的矩阵元素为0，所以可以忽略(<span class=\"math inline\">\\(\\alpha \\oplus 0=\\alpha\\)</span>)，即先得到<span class=\"math inline\">\\(D_1\\oplus D_5\\)</span>。接下来再利用<span class=\"math inline\">\\(\\text{galois\\_w\\_region\\_multiply}\\)</span>计算剩余的非<span class=\"math inline\">\\(1\\)</span>的点积，然后将二者异或即得到<span class=\"math inline\">\\(C_i\\)</span>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_bitmatrix_dotprod</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> w, <span class=\"keyword\">int</span> *bitmatrix_row,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"keyword\">int</span> *src_ids, <span class=\"keyword\">int</span> dest_id,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                             <span class=\"keyword\">char</span> **data_ptrs, <span class=\"keyword\">char</span> **coding_ptrs, <span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> packetsize)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>含义同上一函数，方法为直接计算。从这里也可看出，<span class=\"math inline\">\\(GF(2)\\)</span>上的点积计算比<span class=\"math inline\">\\(GF(2^w)\\)</span>方便得多。</p>\r\n<h3 id=\"矩阵转置操作函数\">3.2.6 矩阵转置操作函数</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invert_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> *inv, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>利用初等变换法求<span class=\"math inline\">\\(mat\\)</span>的逆矩阵，将结果放入<span class=\"math inline\">\\(inv\\)</span>中。大小为<span class=\"math inline\">\\(rows\\times rows\\)</span>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invert_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> *inv, <span class=\"keyword\">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>利用初等变换法求<span class=\"math inline\">\\(mat\\)</span>的逆矩阵，将结果放入<span class=\"math inline\">\\(inv\\)</span>中。大小为<span class=\"math inline\">\\(rows\\times rows\\)</span>。此时的<span class=\"math inline\">\\(w=1\\)</span>，因此也可以用<span class=\"math inline\">\\(jerasure\\_invert\\_matrix\\)</span>求逆，但是该函数的时间复杂度为<span class=\"math inline\">\\(O(n^2)\\)</span>，用上一函数令<span class=\"math inline\">\\(w=1\\)</span>的时间复杂度为<span class=\"math inline\">\\(O(n^3)\\)</span>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invertible_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>判断<span class=\"math inline\">\\(mat\\)</span>是否可逆，不会求逆。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">jerasure_invertible_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *mat, <span class=\"keyword\">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>同上，判断<span class=\"math inline\">\\(mat\\)</span>是否可逆，不会求逆。</p>\r\n<h3 id=\"一些基本的矩阵操作函数\">3.2.7 一些基本的矩阵操作函数</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>输出<span class=\"math inline\">\\(matrix\\)</span>，根据<span class=\"math inline\">\\(w\\)</span>的大小确定列间距。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *matrix, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p>输出<span class=\"math inline\">\\(matrix\\)</span>，每<span class=\"math inline\">\\(w\\)</span>个字符后插入一个空格，每<span class=\"math inline\">\\(w\\)</span>行后插入一个空白行。</p>\r\n<p>例如：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_matrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *m, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fw;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[<span class=\"number\">30</span>];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> w2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (w == <span class=\"number\">32</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fw = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        w2 = (<span class=\"number\">1</span> &lt;&lt; w);</span><br><span class=\"line\">        <span class=\"built_in\">sprintf</span>(s, <span class=\"string\">&quot;%u&quot;</span>, w2 - <span class=\"number\">1</span>);</span><br><span class=\"line\">        fw = <span class=\"built_in\">strlen</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%*u&quot;</span>, fw, m[i * cols + j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_print_bitmatrix</span><span class=\"params\">(<span class=\"keyword\">int</span> *m, <span class=\"keyword\">int</span> rows, <span class=\"keyword\">int</span> cols, <span class=\"keyword\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; rows; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span> &amp;&amp; i % w == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; cols; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j != <span class=\"number\">0</span> &amp;&amp; j % w == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, m[i * cols + j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mat[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, </span><br><span class=\"line\">    \t\t\t <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bitmat[<span class=\"number\">6</span>*<span class=\"number\">15</span>] = &#123;   <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                           <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                           <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                           </span><br><span class=\"line\">                           <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                           <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                           <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>,    <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    jerasure_print_matrix(mat, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    jerasure_print_bitmatrix(bitmat, <span class=\"number\">2</span>*<span class=\"number\">3</span>, <span class=\"number\">5</span>*<span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    system(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>输出结果为： <img src=\"https://img-blog.csdnimg.cn/20201117145029289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjg2ODg0OQ==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"输出结果\" /> <figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">jerasure_matrix_multiply</span><span class=\"params\">(<span class=\"keyword\">int</span> *m1, <span class=\"keyword\">int</span> *m2, <span class=\"keyword\">int</span> r1, <span class=\"keyword\">int</span> c1, <span class=\"keyword\">int</span> r2, <span class=\"keyword\">int</span> c2, <span class=\"keyword\">int</span> w)</span></span>;</span><br></pre></td></tr></table></figure> 计算矩阵乘法。<span class=\"math inline\">\\(m_1\\)</span>为<span class=\"math inline\">\\(r_1\\times c_1\\)</span>，<span class=\"math inline\">\\(m_2\\)</span>为<span class=\"math inline\">\\(r_2\\times c_2\\)</span>，计算<span class=\"math inline\">\\(m_1\\times m_2\\)</span>，显然<span class=\"math inline\">\\(c_1=r_2\\)</span>。</p>\r\n<h3 id=\"监测函数\">3.2.8 监测函数</h3>\r\n<p>为评估编解码性能，JErasure库提供了一个监测函数。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_get_stats</span><span class=\"params\">(<span class=\"keyword\">double</span> *fill_in)</span></span>;</span><br></pre></td></tr></table></figure>\r\n<p><code>fill_in</code>是含有<span class=\"math inline\">\\(3\\)</span>个<code>double</code>类型的向量，分别评价三个指标，其含义分别为：</p>\r\n<ol type=\"1\">\r\n<li><p>使用`galois_region_xor()进行了XOR运算的字节数；</p></li>\r\n<li><p>使用<code>galois_w08_region_multiply()</code>, <code>galois_w16_region_multiply()</code> or <code>galois_w32_region_multiply()</code>来乘以常数的字节数，即<span class=\"math inline\">\\(\\text{region}\\)</span>的长度；</p></li>\r\n<li><p>使用<span class=\"math inline\">\\(\\text{memcpy()}\\)</span>复制的字节数。</p></li>\r\n</ol>\r\n<p>调用该函数之后，上述三个指标将会被清空。具体如下：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">jerasure_get_stats</span><span class=\"params\">(<span class=\"keyword\">double</span> *fill_in)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  fill_in[<span class=\"number\">0</span>] = jerasure_total_xor_bytes;</span><br><span class=\"line\">  fill_in[<span class=\"number\">1</span>] = jerasure_total_gf_bytes;</span><br><span class=\"line\">  fill_in[<span class=\"number\">2</span>] = jerasure_total_memcpy_bytes;</span><br><span class=\"line\">  jerasure_total_xor_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  jerasure_total_gf_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">  jerasure_total_memcpy_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["JErasure"],"tags":["galois field","Reed-Solomon Code","JErasure"]},{"title":"八方旅人 -- 壁纸 (1920×1080)","url":"/2021/11/11/octopath/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><code>Alpyn</code></p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"alpyn.jpg\" /></p>\r\n<p><code>Cyrus</code></p>\r\n<p><img src=\"cyrus.jpg\" /></p>\r\n<p><code>haaint</code></p>\r\n<p><img src=\"haaint.jpg\" /></p>\r\n<p><code>Olberic</code></p>\r\n<p><img src=\"olberic.jpg\" /></p>\r\n<p><code>Ophilia</code></p>\r\n<p><img src=\"ophilia.jpg\" /></p>\r\n<p><code>Primrose</code></p>\r\n<p><img src=\"primrose.jpg\" /></p>\r\n<p><code>Therion</code></p>\r\n<p><img src=\"therion.jpg\" /></p>\r\n<p><code>Tressia</code></p>\r\n<p><img src=\"tressia.jpg\" /></p>\r\n<hr />\r\n<p><code>ART1</code></p>\r\n<p><img src=\"art1.jpg\" /></p>\r\n<p><code>ART2</code></p>\r\n<p><img src=\"art2.jpg\" /></p>\r\n<p><code>ART3</code></p>\r\n<p><img src=\"art3.jpg\" /></p>\r\n","categories":["OCTOPATH"],"tags":["OCTOPATH","paperwall"]},{"title":"【置顶】更新日志","url":"/2021/11/11/top/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><span class=\"math display\">\\[\r\n\\LARGE{2021.11}\r\n\\]</span></p>\r\n<hr />\r\n<span id=\"more\"></span>\r\n<p><span class=\"math display\">\\[\r\n\\Large{2021.11.18}\r\n\\]</span></p>\r\n<ul>\r\n<li>更新 <code>CUDA</code> 相关博文</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\Large{2021.11.12}\r\n\\]</span></p>\r\n<ul>\r\n<li>新增站内搜索功能</li>\r\n<li>新增点击特效</li>\r\n<li>新增音乐</li>\r\n<li>修复了搜索功能失效的问题</li>\r\n<li>新增音乐列表</li>\r\n<li>修复音乐无法点击播放的问题</li>\r\n<li>新增音乐全局播放</li>\r\n<li>新增音乐进度条</li>\r\n<li>新增站内页面跳转不打断音乐播放</li>\r\n<li>新增打赏功能</li>\r\n<li>更新 <code>CUDA</code> 相关博文</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\Large{2021.11.11}\r\n\\]</span></p>\r\n<ul>\r\n<li>修复归档导致页面崩溃的 <code>BUG</code></li>\r\n<li>新增评论功能</li>\r\n<li>新增友链</li>\r\n<li>上传 <code>CUDA</code> 相关博文</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\Large{2021.11.10}\r\n\\]</span></p>\r\n<ul>\r\n<li>修复无法正确识别图片的 <code>BUG</code></li>\r\n<li>新增归档功能</li>\r\n<li>新增标签功能</li>\r\n<li>新增归类功能</li>\r\n<li>上传 <code>JErasure</code> 库的相关博文</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\Large{2021.11.09}\r\n\\]</span></p>\r\n<ul>\r\n<li>创建博客</li>\r\n<li>新增 <code>nexT</code> 渲染模式</li>\r\n<li>新增了一些良性 <code>BUG</code></li>\r\n<li>上传第一篇博客</li>\r\n</ul>\r\n","categories":["LOG"],"tags":["logs"]},{"title":"CUDA beginning","url":"/2021/11/11/CUDA-beginning/","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"什么是-cuda\">〇、 什么是 <code>CUDA</code></h1>\r\n<p><code>CUDA</code>（<code>Compute Unified Device Architecture</code>），是显卡厂商 <a href=\"https://baike.baidu.com/item/NVIDIA\"><code>NVIDIA</code></a> 推出的运算平台。 CUDA™是一种由NVIDIA推出的通用 <a href=\"https://baike.baidu.com/item/并行计算/113443\">并行计算</a> 架构，该架构使 <a href=\"https://baike.baidu.com/item/GPU\"><code>GPU</code></a> 架构，该架构使 <a href=\"https://baike.baidu.com/item/GPU\"><code>GPU</code></a> 能够解决复杂的计算问题。 它包含了CUDA<a href=\"https://baike.baidu.com/item/指令集架构\">指令集架构</a>（<a href=\"https://baike.baidu.com/item/ISA\"><code>ISA</code></a>）以及GPU内部的并行计算引擎。 开发人员可以使用<a href=\"https://baike.baidu.com/item/C语言\"><code>C</code>语言</a>来为<code>CUDA™</code>架构编写程序，所编写出的程序可以在支持<code>CUDA™</code>的处理器上以超高性能运行。</p>\r\n<hr />\r\n<span id=\"more\"></span>\r\n<h1 id=\"一-引言\">一、 引言</h1>\r\n<h2 id=\"gpu-的诞生\">1.1 <code>GPU</code> 的诞生</h2>\r\n<p>​ <code>CPU</code>的计算速度无法满足需求，大部分坐标处理工作及光影特效需要 <code>CPU</code> 亲自完成，占用太多运算时间，造成整体画面不能流畅的表现出来。随着时间的推移，<code>CPU</code> 进行各种光影计算的速度变得越来越无法满足游戏开发商的需求，更多特效的应用也几乎榨干了 <code>CPU</code> 的性能，因此，矛盾产生了，<code>GPU</code> 应运而生。</p>\r\n<h2 id=\"gpu-概述\">1.2 <code>GPU</code> 概述</h2>\r\n<p><code>GPU</code>（<code>Graphics Processing Unit</code>）是一种特殊类型的处理器，具有数百或数千个内核，可并行运行大量计算。<code>GPU</code>是一种专门在<code>PC</code>，游戏机，手机等设备上上运行绘图运算工作的<a href=\"https://baike.hk.xileso.top/baike-微處理器\">微处理器</a>。虽然<code>GPU</code>在游戏中以<a href=\"https://baike.hk.xileso.top/baike-3D渲染\">3D</a><a href=\"https://baike.hk.xileso.top/baike-3D渲染\">渲染</a>而闻名，但它们对运行分析、<a href=\"https://baike.hk.xileso.top/baike-深度学习\">深度学习</a>和<a href=\"https://baike.hk.xileso.top/baike-机器学习\">机器学习</a>算法尤其有用。GPU允许某些计算比传统CPU上运行相同的计算速度快<code>10</code>倍至<code>100</code>倍。</p>\r\n<h2 id=\"cuda-产生\">1.3 <code>CUDA</code> 产生</h2>\r\n<p><code>GPU</code>的高效在于可以高度并行处理。 以两个向量相加为例，<code>CPU</code>可能采取循环处理，每个循环对一个分量做加法。<code>GPU</code>则可以开多个线程，每个线程同时对一个分量做加法。<code>CPU</code>加法的速度一般快于<code>GPU</code>，但因为<code>GPU</code>可以同时开大量线程并行跑，因此更加高效。</p>\r\n<p>为了降低<code>GPU</code>程序的开发难度，<code>NVIDIA</code>推出了 <code>CUDA</code>（<code>Compute Unified Device Architecture</code>，统一计算设备架构）这一编程模型。</p>\r\n<h2 id=\"cpu-和-gpu-模型对比\">1.4 <code>CPU</code> 和 <code>GPU</code> 模型对比</h2>\r\n<h3 id=\"cpu-架构\">1.4.1 <code>CPU</code> 架构</h3>\r\n<p><img src=\"CPU%20Arch.png\" /></p>\r\n<p><code>CPU</code>（<code>Central Processing Unit</code>, 中央处理器）：<code>CPU</code>的结构主要包括运算器（<code>ALU</code>, <code>Arithmetic and Logic Unit</code>）、控制单元（<code>CU</code>, <code>Control Unit</code>）、寄存器（<code>Register</code>）、高速缓存器（<code>Cache</code>）等。简单来说就是<strong>计算单元，控制单元，存储单元</strong>。<strong>计算能力</strong>是CPU的很小的一部分功能。</p>\r\n<ul>\r\n<li><p><code>ALU</code> — 运算单元</p></li>\r\n<li><p><code>Control</code> — 控制单元</p></li>\r\n<li><p><code>Cache</code> — 高速缓存（<code>CPU</code>和内存之间的中介桥梁），进行高速数据交换的存储器</p></li>\r\n<li><p><code>DRAM</code>— 进行短暂存储的存储器，易失性存储器（电源开启时数据存在，断开电源数据消失）</p></li>\r\n</ul>\r\n<p>可以看出 <code>CPU</code><strong>是基于低延迟设计</strong> 的。因为它有<strong>特别大的缓存空间可以降低延时</strong>，可以保存较多数据在缓存里面，当需要访问的这些数据时，只要在之前访问过的，现在直接在缓存里面取即可。</p>\r\n<p>此外，<code>CPU</code>具有复杂的控制单元。例如当程序含有多个分支的时候，它可以通过提供分支预测的能力来降低延时。再比如在数据转发时，当一些指令依赖前面的指令结果时，数据转发的逻辑控制单元决定这些指令在<code>pipeline</code>中的位置并且尽可能快的转发一个指令的结果给后续的指令。这些动作需要很多的对比电路单元和转发电路单元。</p>\r\n<p>因为<code>CPU</code>的架构中需要大量的空间去放置存储单元和控制单元，相比之下计算单元只占据了很小的一部分，所以它在大规模并行计算能力上极受限制，而更擅长于逻辑控制。</p>\r\n<h3 id=\"gpu-架构\">1.4.2 <code>GPU</code> 架构</h3>\r\n<p><img src=\"GPU%20Arch.png\" /></p>\r\n<p><code>GPU</code>的结构里有大量的<code>ALU</code>（计算单元）单元和很少的<code>Cache</code>（缓存）。</p>\r\n<p><code>GPU</code>的<code>Cache</code>不是像<code>CPU</code>那样保存后面需要访问的数据的，它是为<code>thread</code>（线程）提供服务的。如果有很多线程需要访问同一个相同的数据，缓存会合并这些访问，然后再去访问<code>dram</code>（因为需要访问的数据保存在<code>dram</code>中而不是<code>cache</code>里面），获取数据后<code>cache</code>会转发这个数据给对应的线程，这个时候<code>Cache</code>是作为数据转发的角色。但是由于需要访问<code>dram</code>，自然会带来延时的问题。</p>\r\n<p><code>GPU</code>的工作大部分都计算量大，但没什么技术含量，而且要<strong>重复很多很多次</strong>。也就是说，<code>GPU</code>是用很多简单的计算单元去完成大量的计算任务，纯粹的人海战术。所以<code>GPU</code>的计算特点就是<strong>超长的流水线</strong>和<strong>并行计算</strong>。显然，<code>GPU</code>是基于高吞吐量设计的。</p>\r\n<h2 id=\"串行计算和并行计算\">1.5 串行计算和并行计算</h2>\r\n<p>串行计算可以看成是将某个任务分解成一系列小任务，把这些小任务一一完成。在串行计算时，我们的想法就是让处理器每次处理一个计算任务，处理完一个计算任务后再计算下一个任务，直到所有小任务都完成了，那么这个大的程序任务也就完成了。<code>CPU</code> 的每个核心自身能力极强，处理任务上非常强悍，但是他核心少，所以 <code>CPU</code> 特别擅长串行计算。</p>\r\n<p><img src=\"sol.png\" /></p>\r\n<p>当我们可以利用多核处理器同时处理多个任务时，为了进一步加快大任务的计算速度，我们可以把一些小任务分配到不同的处理器上进行同时计算，最后再将这些结果进行整合，完成一次任务计算。<code>GPU</code>的每个核心的计算能力不如<code>CPU</code>，但是它核心非常多，可同时处理多个计算任务，所以<code>GPU</code>擅长并行计算。</p>\r\n<p><img src=\"par.png\" /></p>\r\n<p>所以，要加快程序的运行速度，可以先分析程序中哪些部分是强耦合的，哪些部分是相对独立的，对于强耦合的部分可以使用串行计算，而对于相对独立的部分，则可以充分利用多核处理器的优势进一步加速我们的计算任务，使用并行计算加快计算速度。因此，利用串行+并行的编程思路即可完成一次高性能计算，也就是充分利用<code>CPU</code>和<code>GPU</code>的优势来使程序性能得到优化。</p>\r\n<h1 id=\"二-cuda-模型\">二、 <code>CUDA</code> 模型</h1>\r\n<h2 id=\"cuda-程序执行过程\">2.1 <code>CUDA</code> 程序执行过程</h2>\r\n<p>典型的<code>CUDA</code>程序实现流程如下：</p>\r\n<ol type=\"1\">\r\n<li>把数据从<code>CPU</code>内存拷贝到<code>GPU</code>内存；</li>\r\n<li>调用核函数对存储在<code>GPU</code>内存中的数据进行操作；</li>\r\n<li>将数据从<code>GPU</code>内存传送到<code>CPU</code>内存。</li>\r\n</ol>\r\n<p><img src=\"cuda1.png\" /></p>\r\n<h2 id=\"cuda-线程模型\">2.2 <code>CUDA</code> 线程模型</h2>\r\n<p><code>kernel</code>在<code>device</code>上执行时实际上是启动很多线程，一个<code>kernel</code>所启动的所有线程称为一个网格（<code>grid</code>），同一个网格上的线程共享相同的全局内存空间，<code>grid</code>是线程结构的第一层次，而网格又可以分为很多线程块（<code>block</code>），一个线程块里面包含很多线程，这是第二个层次。</p>\r\n<p><img src=\"thread.png\" /></p>\r\n<p>理想的主机端的串行代码只负责上一个<code>kernel</code>函数的清理和为下一个<code>kernel</code>函数进行准备，这样可以充分发挥<code>GPU</code>的高效运算能力，减少内存和显存之间传递数据的开销。但是在实践中一般无法将所有的计算任务交给设备端处理，主机端的串行代码中还应包含一些并行度较小的计算任务。</p>\r\n<h2 id=\"cuda-内存模型\">2.3 <code>CUDA</code> 内存模型</h2>\r\n<p><code>CUDA</code>编程模型本质是从<code>GPU</code>架构中抽象出的一个内存层次结构，通过在<code>CUDA</code>上进行开发可以对<code>GPU</code>不同的内存层次进行处理。由于<code>LRC</code>码在编解码的过程中会进行数据的分组分割，需要对原始数据块进行存储处理等操作，为了加快<code>LRC</code>码的编解码性能，可以将分割分组后的数据存储到<code>GPU</code>的不同内存层次中去，这一点可以利用<code>CUDA</code>编程实现。因此，对于<code>CUDA</code>模型中不同的内存层次结构的了解很有必要。</p>\r\n<p>在设备端全局内存类似于<code>CPU</code>的系统内存，具有存储空间大但是内存带宽低、时延较高的特点，而共享内存则类似于<code>CPU</code>的缓存，具有的存储空间比线程自带的寄存器空间要大且拥有高内存带宽以及低时延。其中，<code>GPU</code>的共享内存可以由<code>CUDA_C</code>的内核直接控制。</p>\r\n<p><img src=\"memory.png\" /></p>\r\n<p>上图即为 <code>CUDA</code> 内存模型，前文已经介绍过 <code>Grid - Block - Thread</code> 的线程结构，在内存模型中，一个 <code>Grid</code> 中的所有 <code>Block</code> 的线程可以共享访问 <strong>全局内存</strong> 、 <strong>常量内存</strong> 、 <strong>纹理内存</strong> 的数据，在一个 <code>Block</code> 中，所有线程 <code>Thread</code> 可以共享访问 <strong>本地内存</strong> （<strong>共享内存</strong>）的数据。</p>\r\n<h1 id=\"三-cuda-核函数\">三、 <code>CUDA</code> 核函数</h1>\r\n<p>假如我们要计算 <code>10000</code> 个 <code>0</code> 到 <code>9</code> 的随机数立方和，用 <code>C</code> 写应该是这样：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DATA_SIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// generate random number</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GenerateFunc</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        dat[i] = rand() % <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getRes</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        ret += dat[i] * dat[i] * dat[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    srand(time(<span class=\"literal\">NULL</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[DATA_SIZE];</span><br><span class=\"line\">    GenerateFunc(data, DATA_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = getRes(data, DATA_SIZE);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ret = %d\\n&quot;</span>, ret);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>那么我们如何让这个工作在显卡上完成呢？首先第一件事很显而易见，这些数字不能放在内存里了，而是要复制到<code>GPU</code>的显存上。</p>\r\n<p>前文已经介绍过，在 <code>CUDA</code>的架构下，一个程序分为两个部份：<code>host</code>端和 <code>device</code>端。<code>Host</code>端是指在 <code>CPU</code>上执行的部份，而 <code>device</code>端则是在显示芯片上执行的部份。<code>Device</code>端的程序又称为 <code>kernel</code>。通常 <code>host</code>端程序会将数据准备好后，复制到显卡的内存中，再由显示芯片执行 <code>device</code>端程序，完成后再由 <code>host</code>端程序将结果从显卡的内存中取回。</p>\r\n<p>我们需要把产生的数据复制到<code>Device</code>端的<code>RAM</code>，才能在显卡上完成计算，因此我们首先开辟一块合适的显存，然后把随机数从内存复制进去。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*把数据复制到显卡内存中*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* gpudata, *result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cudaMalloc 取得一块显卡内存 ( 其中result用来存储计算结果 )</span></span><br><span class=\"line\">cudaMalloc((<span class=\"keyword\">void</span>**)&amp;gpudata, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE);</span><br><span class=\"line\">cudaMalloc((<span class=\"keyword\">void</span>**)&amp;result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpy 将产生的随机数复制到显卡内存中 </span></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpyHostToDevice - 从内存复制到显卡内存</span></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpyDeviceToHost - 从显卡内存复制到内存</span></span><br><span class=\"line\">cudaMemcpy(gpudata, data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE,cudaMemcpyHostToDevice);</span><br></pre></td></tr></table></figure>\r\n<p><code>cudaMalloc</code>和 <code>cudaMemcpy</code>的用法和一般的 <code>malloc</code>及 <code>memcpy</code>类似，不过 <code>cudaMemcpy</code>则多出一个参数，指示复制内存的方向。在这里因为是从主内存复制到显卡内存，所以使用 <code>cudaMemcpyHostToDevice</code>。如果是从显卡内存到主内存，则使用<code>cudaMemcpyDeviceToHost</code>。</p>\r\n<p>完成了从内存到显存的数据拷贝之后，我们接下来就要在显卡上完成计算了。</p>\r\n<p><code>CUDA</code> 核函数就是要写在显示芯片上执行的程序。在 <code>CUDA</code>中，在函数前面加上<code>__global__</code> 表示这个函式是要在显示芯片上执行的,所以我们只要在正常函数之前加上一个<code>__global__</code>就行了：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getRes</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span>* res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; DATA_SIZE; i++) &#123;</span><br><span class=\"line\">        sum += dat[i] * dat[i] * dat[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *res = sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>可以看到，在 <code>C</code> 源代码中该接口是以 <code>int</code> 型返回的，但是这里的返回值是 <code>void</code> ，需要注意，所有在 <code>device</code> 端执行的代码，即前缀包含 <code>__global__</code> 的接口必须以 <code>void</code> 返回，也就是无返回值，所有需要返回的数据都要在参数列表中以参数的形式传入和修改。</p>\r\n<p>写好核函数之后需要让<code>CUDA</code>执行这个函数。在 <code>CUDA</code>中，要执行一个核函数，使用以下的语法：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">functionName&lt;&lt;&lt;blockNum, threadNum, shared_memory_size&gt;&gt;&gt;(args...);</span><br></pre></td></tr></table></figure>\r\n<p>例如，我们令 <code>block</code> 数量为 <code>1</code> ，每个 <code>block</code> 中的 <code>thread</code> 数量为 <code>1</code>，不使用共享内存，则调用核函数的接口的方式为：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">getRes&lt;&lt;&lt;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&gt;&gt;&gt;(gpudata, result);</span><br></pre></td></tr></table></figure>\r\n<p>很显然，令 <code>block</code> 数量为 <code>1</code> ，每个 <code>block</code> 中的 <code>thread</code> 数量为 <code>1</code>，不使用共享内存，这样的话就是单纯的让单个线程完成计算，没有涉及到多线程并行计算。计算完了，千万别忘了还要<strong>把结果从显示芯片复制回主内存上</strong>，然后<strong>释放掉内存</strong>。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//cudaMemcpy -- copy result from device to host</span></span><br><span class=\"line\">cudaMemcpy(&amp;sum, result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), cudaMemcpyDeviceToHost);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Free memory</span></span><br><span class=\"line\">cudaFree(gpudata);</span><br><span class=\"line\">cudaFree(result);</span><br></pre></td></tr></table></figure>\r\n<p>完整程序：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//CUDA RunTime API</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cuda_runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DATA_SIZE 10000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> data[DATA_SIZE];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GenerateFunc</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">        dat[i] = rand() % <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CUDA 初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">InitCUDA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"comment\">//取得支持Cuda的装置的数目</span></span><br><span class=\"line\">    cudaGetDeviceCount(&amp;count);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;There is no device.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">        cudaDeviceProp prop;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cudaGetDeviceProperties(&amp;prop, i) == cudaSuccess) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prop.major &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == count) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;There is no device supporting CUDA 1.x.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cudaSetDevice(i);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">getRes</span><span class=\"params\">(<span class=\"keyword\">int</span>* dat, <span class=\"keyword\">int</span>* res)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; DATA_SIZE; i++) &#123;</span><br><span class=\"line\">        sum += dat[i] * dat[i] * dat[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *res = sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//CUDA 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!InitCUDA()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    GenerateNumbers(data, DATA_SIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>* gpudata, *result;</span><br><span class=\"line\">    cudaMalloc((<span class=\"keyword\">void</span>**)&amp;gpudata, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE);</span><br><span class=\"line\">    cudaMalloc((<span class=\"keyword\">void</span>**)&amp;result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    cudaMemcpy(gpudata, data, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)* DATA_SIZE, cudaMemcpyHostToDevice);</span><br><span class=\"line\">    sumOfSquares &lt;&lt;&lt;<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&gt;&gt;&gt;(gpudata, result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\">    cudaMemcpy(&amp;sum, result, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), cudaMemcpyDeviceToHost);</span><br><span class=\"line\"></span><br><span class=\"line\">    cudaFree(gpudata);</span><br><span class=\"line\">    cudaFree(result);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;GPU result: %d\\n&quot;</span>, sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; DATA_SIZE; i++) &#123;</span><br><span class=\"line\">        sum += data[i] * data[i] * data[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;CPU result: %d\\n&quot;</span>, sum);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"四-核函数运行参数\">四、 核函数运行参数</h1>\r\n<p>上一个部分介绍了核函数的一种调用形式：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">functionName&lt;&lt;&lt;blockNum, threadNum, shared_memory_size&gt;&gt;&gt;(args...);</span><br></pre></td></tr></table></figure>\r\n<p>其中 <code>&lt;&lt;&lt; &gt;&gt;&gt;</code> 标识了核函数的启动方式。实际上，当我们定义了核函数，并将其标识为 <code>__global__</code> 后：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">kernel</span><span class=\"params\">(param1, ...)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在主机端调用时应采用如下的形式：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">kernel&lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt;(param1, ...);</span><br></pre></td></tr></table></figure>\r\n<p>其中：</p>\r\n<ul>\r\n<li><code>Dg</code> 是 <code>dim3</code> 类型的， <code>dim3</code> 即基于 <code>unsigned int</code> 定义的矢量类型，实质上是 <code>3</code> 个 <code>unsigned int</code> 组成的结构体，用来定义 <code>grid</code> 的维度和尺寸，即 <code>grid</code> 每行有 <code>Dg.x</code> 个 <code>block</code> ，每列有 <code>Dg.y</code> 个 <code>block</code> ，高度为 <code>Dg.z</code> ；</li>\r\n<li><code>Db</code> 是 <code>dim3</code> 类型的，用来定义 <code>block</code> 的维度和尺寸，即 <code>block</code> 每行有 <code>Db.x</code> 个 <code>thread</code> ，每列有 <code>Db.y</code> 个 <code>thread</code> ，高度为 <code>Db.z</code> ；</li>\r\n<li><code>Ns</code>： <code>size_t</code> 类型，可缺省，默认为 <code>0</code> 。 用于设置每个 <code>block</code> 除了静态分配的共享内存外，最多能动态分配的共享内存大小，单位为 <code>byte</code> 。 <code>0</code> 表示不需要动态分配；</li>\r\n<li><code>S</code>： <code>cudaStream_t</code> 类型，可缺省，默认为 <code>0</code> 。 表示该核函数位于哪个流。</li>\r\n</ul>\r\n<p>前面已经介绍了 <code>GPU</code> 的线程结构，结合之前的线程结构更容易理解。</p>\r\n<h2 id=\"核函数举例之矢量相加\">4.1 核函数举例之矢量相加</h2>\r\n<h3 id=\"一维-grid-一维-block\">4.1.1 一维 <code>grid</code> ，一维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"一维-grid-二维-block\">4.1.2 一维 <code>grid</code> ，二维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 2-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x * blockDim.y + threadIdx.y * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"一维-grid-三维-block\">4.1.3 一维 <code>grid</code> ，三维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 3-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x * blockDim.y * blockDim.z</span><br><span class=\"line\">            + threadIdx.z * blockDim.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"二维-grid-一维-block\">4.1.4 二维 <code>grid</code> ，一维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G2_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 2-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"二维-grid-二维-block\">4.1.5 二维 <code>grid</code> ，二维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G2_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 2-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 2-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"二维-grid-三维-block\">4.1.6 二维 <code>grid</code> ，三维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G2_B3</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 2-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 3-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y * blockDim.z)</span><br><span class=\"line\">            + threadIdx.z * (blockDim.y * blockDim.x)</span><br><span class=\"line\">            + threadIdx.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"三维-grid-一维-block\">4.1.7 三维 <code>grid</code> ，一维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G3_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 3-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.z * gridDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"三维-grid-二维-block\">4.1.8 三维 <code>grid</code> ，二维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G3_B2</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 3-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 2-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.z * gridDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y) + (threadIdx.y * blockDim.x) + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"三维-grid-三维-block\">4.1.9 三维 <code>grid</code> ，三维 <code>block</code></h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G3_B3</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 3-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 3-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bid = blockIdx.z * gridDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = bid * (blockDim.x * blockDim.y * blockDim.z)</span><br><span class=\"line\">            + threadIdx.z * (blockDim.y * blockDim.x)</span><br><span class=\"line\">            + threadIdx.y * blockDim.x</span><br><span class=\"line\">            + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"任务调度\">4.2 任务调度</h2>\r\n<p>以上面的 <code>addKernel_G1_B1</code> 为例：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel_G1_B1</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// grid  -- 1-dim</span></span><br><span class=\"line\">    <span class=\"comment\">// block -- 1-dim</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    ret[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addKernel_G1_B1&lt;&lt;&lt;<span class=\"number\">1</span>, size&gt;&gt;&gt;(dev, dev_a, dev_b);</span><br></pre></td></tr></table></figure>\r\n<p>当 <code>size &gt; 1024</code> 时，矢量会过长，因为一个 <code>block</code> 能容纳的线程数至多为 <code>1024</code> 。于是我们可以采用多个线程块来解决线程不足的问题。 假如我们设定每个线程块包含 <code>128</code> 个线程，则需要的线程块的数量为 <code>size / 128</code> 。 为了避免不能整除带来的问题，我们可以稍微多开一点 <code>(size + 127) / 128</code> ，但需要增加判断条件来避免越界。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tid &lt; size)</span><br><span class=\"line\">        c[tid] = a[tid] + b[tid];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行核函数，运行设置为多个block，每个block中128个线程</span></span><br><span class=\"line\">addKernel &lt;&lt;&lt;(size + <span class=\"number\">127</span>) / <span class=\"number\">128</span>, <span class=\"number\">128</span> &gt;&gt;&gt;(dev, dev_a, dev_b, size);</span><br></pre></td></tr></table></figure>\r\n<p>如果数据量大于 <code>Block_num * Thread_num</code>，那么我们就无法为每个分量单独分配一个线程了。 不过，一个简单的解决办法就是在核函数中增加循环。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">addKernel</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* a, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>* b, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tid &lt; size)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        c[tid] = a[tid] + b[tid];</span><br><span class=\"line\">        <span class=\"comment\">// 偏移分量等于一个Grid中包含的线程数量</span></span><br><span class=\"line\">        tid += blockDim.x * gridDim.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行核函数，运行设置为1个Grid包含128个block，每个block包含128个线程</span></span><br><span class=\"line\"><span class=\"comment\">// 其中已经假设 size &gt; 128*128</span></span><br><span class=\"line\">addKernel&lt;&lt;&lt;<span class=\"number\">128</span>, <span class=\"number\">128</span>&gt;&gt;&gt;(dev, dev_a, dev_b, size);</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"线程同步\">4.3 线程同步</h2>\r\n<p>同一个 <code>Block</code> 中的线程可以访问一块共享内存。由于共享内存缓冲区驻留在物理 <code>GPU</code> 上（片上内存），而不是 <code>GPU</code> 之外的系统内存（片外内存）上，因此访问共享内存的延迟要远远低于访问普通缓冲区的延迟。</p>\r\n<p>不同 <code>Block</code> 之间存在隔离，如果我们需要不同线程之间进行通信，那么还需要考虑线程同步的问题。比如线程<code>1</code> 将某个数值写入内存，然后线程 <code>2</code> 会对该数值进行一些操作，那么显然必须等 <code>1</code> 完成之后 <code>2</code> 才可以操作，如果没有同步，程序将会因进入“竞态条件”而产生意想不到的错误。</p>\r\n<p>举个栗子：</p>\r\n<p>求向量点积，如四维向量的点积为： <span class=\"math display\">\\[\r\n(x_1, x_2, x_3, x_4)\\cdot (y_1, y_2, y_3, y_4)=x_1y_1 + x_2y_2 + x_3y_3 + x_4y_4\r\n\\]</span> 现在假设进行点积运算的两个向量的长度为 <code>33 * 1024</code> ，使用 <code>32</code> 个线程块，每个线程块使用 <code>256</code> 个线程。</p>\r\n<h3 id=\"step-1.-申请共享内存\">Step 1. 申请共享内存</h3>\r\n<p>首先申请共享内存，例如申请一个数组 <code>cache</code> ：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">__shared__ <span class=\"keyword\">int</span> cache[threadsPerBlock];</span><br></pre></td></tr></table></figure>\r\n<p>我们需要明白的是，一旦这样声明数组，就会创建与线程块的数量相同的数组 <code>cache</code> ，即每个线程块都会对应一个这样的数组 <code>cache</code> 。我们都知道，共享内存是用于同一个线程块内的线程之间交流的，不同线程块之间是无法通过共享内存进行交流的。另外，数组 <code>cache</code> 的大小是每个线程块中线程的个数，即线程块的大小。</p>\r\n<h3 id=\"step-2.-分析每个线程的工作\">Step 2. 分析每个线程的工作</h3>\r\n<p>如果向量长度不是特别长(假设大小等于总线程个数)的话，每个线程只需要工作一次，即计算两个元素的积并保存在中间变量 <code>temp</code> 里。但是实际计算过程中由于向量长度过长，一次计算可能会计算不完，每个线程需要多次计算才能完成所有工作，因此 <code>temp</code> 保存的值可能为多个元素乘积之和。</p>\r\n<p>假设数组大小为 <code>16</code> ，线程总数为 <code>4</code> 。此时一次并行是无法完成工作的，所以需要多次并行，即每个线程需要做四次工作才可完成计算。</p>\r\n<p>那么相应的代码如下：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (tid &lt; N) &#123;</span><br><span class=\"line\">    tmp += a[tid] * b[tid];</span><br><span class=\"line\">    tid += blockDim.x * gridDim.x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>如果你已经理解了上面这个过程，那么你也应该会明白每个线程块移动的步长为什么是总线程的个数了，即 <code>tid += blockDim.x * gridDim.x</code> 这段代码。</p>\r\n<h3 id=\"step-3.-多线程协同\">Step 3. 多线程协同</h3>\r\n<p>要让多线程协同工作，就需要使用到共享内存。每个线程将 <code>tmp</code> 的值保存到每个线程块的共享内存( <code>shared memory</code> )中，即数组 <code>cache</code> 中：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">cache[cacheIdx] = tmp;</span><br><span class=\"line\">__syncthreads();</span><br></pre></td></tr></table></figure>\r\n<p>这样每个线程块中对应的数组 <code>cache</code> 保存的就是每个线程的计算结果。为了节省带宽，这里又采用了并行计算中常用的归约算法，来计算数组中所有值之和，并保存在第一个元素( <code>cache[0]</code> )内。这样每个线程就通过共享内存( <code>shared memory</code> )进行数据交流了。具体代码如下所示：</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//归约算法将每个线程块上的cache数组归约为一个值cache[0]，最终保存在数组c里</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = blockDim.x /<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheIndex &lt; i) &#123;</span><br><span class=\"line\">        cache[cacheIndex] += cache[cacheIndex + i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __syncthreads();</span><br><span class=\"line\"></span><br><span class=\"line\">    i /= <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"step-4.-保存结果\">Step 4. 保存结果</h3>\r\n<p>现在每个线程块的计算结果已经保存到每个共享数组 <code>cache</code> 的第一个元素 <code>cache[0]</code> 中，这样可以大大节省带宽。下面就需要将这些归约结果保存到全局内存( <code>global memory</code> )中。</p>\r\n<p>观察核函数你会发现有一个传入参数——数组 <code>ret</code> 。这个数组是位于全局内存中，每次使用线程块中线程 <code>ID</code> 为 <code>0</code> 的线程来将每个线程块的归约结果保存到该数组中，注意这里每个线程块中的结果保存到数组 <code>ret</code> 中与之相对应的位置，即 <code>c[blockIdx.x]</code>。</p>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (cacheIdx == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ret[blockIdx.x] = cache[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"step-5.-完整代码\">Step 5. 完整代码</h3>\r\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;cuda_runtime.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> N = <span class=\"number\">33</span> * <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> threadsPerBlock = <span class=\"number\">256</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> blocksPerGrid = <span class=\"number\">32</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// kernel</span></span><br><span class=\"line\"><span class=\"function\">__global__ <span class=\"keyword\">void</span> <span class=\"title\">dot</span><span class=\"params\">(<span class=\"keyword\">int</span>* ret, <span class=\"keyword\">int</span>* a, <span class=\"keyword\">int</span>* b)</span> </span>&#123;</span><br><span class=\"line\">    __shared__ <span class=\"keyword\">int</span> cache[threadsPerBlock];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> tid = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> cacheIdx = threadIdx.x;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (tid &lt; N) &#123;</span><br><span class=\"line\">        tmp += a[tid] * b[tid];</span><br><span class=\"line\">        tid += gridDim.x * blockDim.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cache[cacheIdx] = tmp;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __syncthreads();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// int i = threadsPerBlock / 2;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = blockDim.x / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cacheIdx &lt; i) &#123;</span><br><span class=\"line\">            cache[cacheIdx] += cache[cacheIdx + i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        __syncthreads();</span><br><span class=\"line\">        i /= <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheIdx == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ret[blockIdx.x] = cache[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* a = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(N * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* b = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(N * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* ret = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(blocksPerGrid * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// initialize a and b</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        a[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        b[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>* dev_a = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* dev_b = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* dev_ret = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cudaMalloc</span>((<span class=\"keyword\">void</span>**)&amp;dev_a, N * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">cudaMalloc</span>((<span class=\"keyword\">void</span>**)&amp;dev_b, N * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"built_in\">cudaMalloc</span>((<span class=\"keyword\">void</span>**)&amp;dev_ret, blocksPerGrid * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// CPU -&gt; GPU(host -&gt; device)</span></span><br><span class=\"line\">    <span class=\"built_in\">cudaMemcpy</span>(dev_a, a, N * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>), cudaMemcpyHostToDevice);</span><br><span class=\"line\">    <span class=\"built_in\">cudaMemcpy</span>(dev_b, b, N * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>), cudaMemcpyHostToDevice);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// kernel calculate</span></span><br><span class=\"line\">    dot&lt;&lt;&lt;<span class=\"number\">32</span>, <span class=\"number\">256</span>&gt;&gt;&gt;(dev_ret, dev_a, dev_b);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// GPU -&gt; CPU(device -&gt; host)</span></span><br><span class=\"line\">    <span class=\"built_in\">cudaMemcpy</span>(ret, dev_ret, blocksPerGrid * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">int</span>), cudaMemcpyDeviceToHost);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">1</span>; i &lt; blocksPerGrid; ++i) &#123;</span><br><span class=\"line\">        ret[<span class=\"number\">0</span>] += ret[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;The answer is : &quot;</span> &lt;&lt; ret[<span class=\"number\">0</span>] &lt;&lt; std::endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// free memory</span></span><br><span class=\"line\">    <span class=\"built_in\">cudaFree</span>(dev_a);</span><br><span class=\"line\">    <span class=\"built_in\">cudaFree</span>(dev_b);</span><br><span class=\"line\">    <span class=\"built_in\">cudaFree</span>(dev_ret);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","categories":["CUDA"],"tags":["CUDA"]}]